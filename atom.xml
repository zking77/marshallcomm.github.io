<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marshall</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-05T14:59:07.970Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marshall</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Polar Code（3）编码实例</title>
    <link href="http://yoursite.com/2017/03/05/polar-code-3-encoding-example/"/>
    <id>http://yoursite.com/2017/03/05/polar-code-3-encoding-example/</id>
    <published>2017-03-05T12:51:54.000Z</published>
    <updated>2017-03-05T14:59:07.970Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://marshallcomm.github.io/2017/03/04/polar-code-2-encoding-principle/" target="_blank" rel="external">《Polar Code（2）编码原理》</a>中详细阐述了Polar Code编码原理，为更好地理解编码过程，本文将给出一个编码实例。</p><p>设码长为$N=8$，消息比特数$K=4$。列出所有使用到的公式：</p><script type="math/tex;mode=display">c_{1}^{N}=u_{1}^{N}{G_{N}}</script><script type="math/tex;mode=display">{G_{N}}={B_{N}}{F^{\otimes n}}</script><script type="math/tex;mode=display">{F^{\otimes n}}=F\otimes {F^{\otimes \left( n-1 \right)}}</script><script type="math/tex;mode=display">F=\left[ \begin{matrix}
   1 & 0  \\
   1 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{B_{N}}={R_{N}}\left( {I_{2}}\otimes {B_{N/{2}\;}} \right)</script><script type="math/tex;mode=display">{B_{2}}={I_{2}}</script><a id="more"></a><h1 id="计算各分裂子信道的错误概率"><a href="#计算各分裂子信道的错误概率" class="headerlink" title="计算各分裂子信道的错误概率"></a>计算各分裂子信道的错误概率</h1><p>计算出各个极化信道$W_{N}^{\left( i \right)}$的错误概率$P\left( {A_{i}} \right)$，选取$P\left( {A_{i}} \right)$最大的$K$个子信道放置信息比特，其他子信道放置固定比特。这一步的结果即得到$u_{1}^{N}$。</p><p>假设对于一个BEC信道，采用高斯近似法获得$P\left( {A_{i}} \right)$最大的$K$个子信道序号为</p><script type="math/tex;mode=display">A=\left\{ 4,6,7,8 \right\}</script><p>则固定比特序号集合为</p><script type="math/tex;mode=display">{A^{c}}=\left\{ 1,2,3,5 \right\}</script><p>设信息比特集合为$\left( {i_{1}},{i_{2}},{i_{3}},{i_{4}} \right)=\left( 1,1,1,1 \right)$，固定比特集合为$\left( 0,0,0,0 \right)$，则最终得到</p><script type="math/tex;mode=display">u_{1}^{8}=\left[ 0,0,0,{i_{1}},0,{i_{2}},{i_{3}},{i_{4}} \right]=\left[ 0,0,0,1,0,1,1,1 \right]</script><h1 id="构造生成矩阵"><a href="#构造生成矩阵" class="headerlink" title="构造生成矩阵"></a>构造生成矩阵</h1><h2 id="求排序矩阵BN"><a href="#求排序矩阵BN" class="headerlink" title="求排序矩阵BN"></a>求排序矩阵BN</h2><p><strong>递归式：</strong></p><script type="math/tex;mode=display">{B_{8}}={R_{8}}\left( {I_{2}}\otimes {B_{4}} \right)</script><script type="math/tex;mode=display">{B_{4}}={R_{4}}\left( {I_{2}}\otimes {B_{2}} \right)</script><p><strong>计算：</strong></p><script type="math/tex;mode=display">{B_{2}}=\left[ \begin{matrix}
   1 & 0  \\
   0 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{I_{2}}\otimes {B_{2}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0  \\
   0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 1  \\
\end{matrix} \right]</script><p>${R_{4}}$由${I_{4}}$变换得来，先排${I_{4}}$的奇数列，再排${I_{4}}$的偶数列：</p><script type="math/tex;mode=display">{R_{4}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0  \\
   0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 1  \\
\end{matrix} \right]\Leftarrow {I_{4}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0  \\
   0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{B_{4}}={R_{4}}\left( {I_{2}}\otimes {B_{2}} \right)=\left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0  \\
   0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 1  \\
\end{matrix} \right]\cdot \left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0  \\
   0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 1  \\
\end{matrix} \right]\text{=}\left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0  \\
   0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{I_{2}}\otimes {B_{4}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]</script><p>${R_{8}}$由${I_{8}}$变换得来，先排${I_{8}}$的奇数列，再排${I_{8}}$的偶数列：</p><script type="math/tex;mode=display">{R_{8}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]\Leftarrow {I_{8}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{B_{8}}={R_{8}}\left( {I_{2}}\otimes {B_{4}} \right)=\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]\cdot \left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]\text{=}\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]</script><h2 id="求F的n次克罗内克积"><a href="#求F的n次克罗内克积" class="headerlink" title="求F的n次克罗内克积"></a>求F的n次克罗内克积</h2><p><strong>递归式：</strong></p><script type="math/tex;mode=display">{F^{\otimes 3}}=F\otimes {F^{\otimes 2}}</script><script type="math/tex;mode=display">{F^{\otimes 2}}=F\otimes {F^{\otimes 1}}</script><p><strong>计算：</strong></p><script type="math/tex;mode=display">{F^{\otimes 1}}\text{=}F=\left[ \begin{matrix}
   1 & 0  \\
   1 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{F^{\otimes 2}}=F\otimes {F^{\otimes 1}}=\left[ \begin{matrix}
   1 & 0  \\
   1 & 1  \\
\end{matrix} \right]\otimes {F^{\otimes 1}}=\left[ \begin{matrix}
   {F^{\otimes 1}} & 0  \\
   {F^{\otimes 1}} & {F^{\otimes 1}}  \\
\end{matrix} \right]=\left[ \begin{matrix}
   1 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0  \\
   1 & 0 & 1 & 0  \\
   1 & 1 & 1 & 1  \\
\end{matrix} \right]</script><script type="math/tex;mode=display">{F^{\otimes 3}}=F\otimes {F^{\otimes 2}}=\left[ \begin{matrix}
   1 & 0  \\
   1 & 1  \\
\end{matrix} \right]\otimes {F^{\otimes 2}}=\left[ \begin{matrix}
   {F^{\otimes 2}} & 0  \\
   {F^{\otimes 2}} & {F^{\otimes 2}}  \\
\end{matrix} \right]\text{=}\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   1 & 1 & 1 & 1 & 0 & 0 & 0 & 0  \\
   1 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0 & 1 & 1 & 0 & 0  \\
   1 & 0 & 1 & 0 & 1 & 0 & 1 & 0  \\
   1 & 1 & 1 & 1 & 1 & 1 & 1 & 1  \\
\end{matrix} \right]</script><h2 id="求生成矩阵GN"><a href="#求生成矩阵GN" class="headerlink" title="求生成矩阵GN"></a>求生成矩阵GN</h2><script type="math/tex;mode=display">{G_{8}}={B_{8}}{F^{\otimes 3}}=\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 0  \\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
\end{matrix} \right]\cdot \left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   1 & 1 & 1 & 1 & 0 & 0 & 0 & 0  \\
   1 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0 & 1 & 1 & 0 & 0  \\
   1 & 0 & 1 & 0 & 1 & 0 & 1 & 0  \\
   1 & 1 & 1 & 1 & 1 & 1 & 1 & 1  \\
\end{matrix} \right]=\left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   1 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   1 & 0 & 1 & 0 & 1 & 0 & 1 & 0  \\
   1 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0 & 1 & 1 & 0 & 0  \\
   1 & 1 & 1 & 1 & 0 & 0 & 0 & 0  \\
   1 & 1 & 1 & 1 & 1 & 1 & 1 & 1  \\
\end{matrix} \right]</script><h1 id="生成Polar-Code"><a href="#生成Polar-Code" class="headerlink" title="生成Polar Code"></a>生成Polar Code</h1><script type="math/tex;mode=display">c_{1}^{8}=u_{1}^{8}{G_{8}}=\left[ \begin{matrix}
   0 & 0 & 0 & 1 & 0 & 1 & 1 & 1  \\
\end{matrix} \right]\cdot \left[ \begin{matrix}
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\
   1 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\
   1 & 0 & 1 & 0 & 1 & 0 & 1 & 0  \\
   1 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
   1 & 1 & 0 & 0 & 1 & 1 & 0 & 0  \\
   1 & 1 & 1 & 1 & 0 & 0 & 0 & 0  \\
   1 & 1 & 1 & 1 & 1 & 1 & 1 & 1  \\
\end{matrix} \right]=\left[ \begin{matrix}
   0 & 1 & 1 & 0 & 1 & 0 & 0 & 1  \\
\end{matrix} \right]</script><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://marshallcomm.github.io/2017/03/04/polar-code-2-encoding-principle/&quot;&gt;《Polar Code（2）编码原理》&lt;/a&gt;中详细阐述了Polar Code编码原理，为更好地理解编码过程，本文将给出一个编码实例。&lt;/p&gt;&lt;p&gt;设码长为$N=8$，消息比特数$K=4$。列出所有使用到的公式：&lt;/p&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;c_{1}^{N}=u_{1}^{N}{G_{N}}&lt;/script&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;{G_{N}}={B_{N}}{F^{\otimes n}}&lt;/script&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;{F^{\otimes n}}=F\otimes {F^{\otimes \left( n-1 \right)}}&lt;/script&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;F=\left[ \begin{matrix}
   1 &amp; 0  \\
   1 &amp; 1  \\
\end{matrix} \right]&lt;/script&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;{B_{N}}={R_{N}}\left( {I_{2}}\otimes {B_{N/{2}\;}} \right)&lt;/script&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;{B_{2}}={I_{2}}&lt;/script&gt;
    
    </summary>
    
    
      <category term="Polar Code" scheme="http://yoursite.com/tags/Polar-Code/"/>
    
  </entry>
  
  <entry>
    <title>Polar Code（2）编码原理</title>
    <link href="http://yoursite.com/2017/03/04/polar-code-2-encoding-principle/"/>
    <id>http://yoursite.com/2017/03/04/polar-code-2-encoding-principle/</id>
    <published>2017-03-04T05:07:05.000Z</published>
    <updated>2017-03-05T14:57:34.622Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://marshallcomm.github.io/2017/03/01/polar-code-1-summary/" target="_blank" rel="external">《Polar Code（1）概述》</a>中建立了Polar Code初步印象，本文将详细阐述Polar Code编码原理。Polar Code是通过引入信道极化概念而构建的。信道极化分为两个阶段，分别是信道联合和信道分裂。通过信道的联合与分裂，各个子信道的对称容量将呈现两级分化的趋势：随着码长（也就是联合信道数）$N$的增加，一部分子信道的容量趋于1，而其余子信道的容量趋于0。Polar Code正是利用这一信道极化的现象，在容量趋于1的$K$个子信道上传输消息比特，在其余子信道上传输冻结比特（即收发双方已知的固定比特，通常设置为全零）。由此构成的编码即为Polar Code，码率为${K}/{N}\;$。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>一个二进制输入离散无记忆信道（B-DMC）可表示为$W:X\to Y$，$X$是输入符号集合，$Y$是输出符号集合，转移概率为$W\left( y|x \right),x\in X,y\in Y$。由于信道是二进制输入，集合$X=\left\{ 0,1 \right\}$；$Y$和$W\left( y|x \right)$是任意值。对信道$W$的$N$次使用后的信道可表示为${W^{N}}$，则信道${W^{N}}:{X^{N}}\to {Y^{N}}$的转移概率为${W^{N}}\left( y_1^{N}|x_{1}^{N} \right)=\prod\nolimits_{i=1}^{N}{W\left( y|x \right)}$。</p><a id="more"></a><p>对于一个B-DMC $W$，有两个重要的信道参数：</p><p>对称容量（Symmetric Capacity）</p><script type="math/tex;mode=display">I\left( W \right)\triangleq \sum\limits_{y\in Y}{\sum\limits_{x\in X}{\frac{1}{2}}}W\left( y|x \right)\log \frac{W\left( y|x \right)}{\frac{1}{2}W\left( y|0 \right)+\frac{1}{2}W\left( y|1 \right)}</script><p>巴氏参数（Bhattacharyya Parameter）</p><script type="math/tex;mode=display">Z\left( W \right)\triangleq \sum\limits_{y\in Y}{\sqrt{W\left( y|0 \right)W\left( y|1 \right)}}</script><p>$I\left( W \right)$是对信道速率的度量，$Z\left( W \right)$对信道可靠性的度量。$I\left( W \right)$是信道$W$在等概率输入下的可靠传输时的最大速率；而$Z\left( W \right)$是信道$W$只传输0或1下的最大似然判决错误概率的上限。</p><p>$I\left( W \right)$与$Z\left( W \right)$的取值范围均为$\left[ 0,1 \right]$。由于对数以2为底，因此码率和信道容量的单位为bit。$I\left( W \right)$与$Z\left( W \right)$满足这样的关系：且仅当$Z\left( W \right)\approx 0$时，$I\left( W \right)\approx 1$；当且仅当$Z\left( W \right)\approx 1$时，$I\left( W \right)\approx 0$。</p><p>当$W$为对称信道时，$I\left( W \right)$等于香农容量。所谓信道对称，即满足：对于任意$y\in Y$，有$W\left( y|0 \right)=W\left( -y|1 \right)$。二进制对称信道（Binary Symmetric Channel，BSC）和二进制删除信道（Binary Erasure Channel，BEC）都是满足对称性的B-DMC。具体地说，对于$Y=\left\{ 0,1 \right\}$，满足$W\left( 0|0 \right)=W\left( 1|1 \right)$且$W\left( 1|0 \right)=W\left( 0|1 \right)$的B-DMC是为BSC。对于$y\in Y$，满足$W\left( y|0 \right)W\left( y|1 \right)=0$或$W\left( y|0 \right)=W\left( y|1 \right)$的B-DMC是为BEC。对于BEC，符号$y$称为删除符号（Erasure Symbol）。</p><p>行向量$\left( {a_{1}},…,{a_{N}} \right)$在这里简写为$a_{1}^{N}$。对于给定的行向量$a_{1}^{N}$，其子向量表示为$a_{i}^{j},1\le i,j\le N$，且$i\le j$。对于给定的$a_{1}^{N}$和$A\subset \left\{ 1,…,N \right\}$，记${a_{A}}$表示子向量$\left( {a_{i}}:i\in A \right)$。记$a_{1,o}^{j}$表示奇数索引的子向量<br>$\left( {a_{k}}:1\le k\le j;\begin{matrix}<br>k &amp; odd \\<br>\end{matrix} \right)$，记$a_{1,e}^{j}$表示偶数索引的子向量$\left( {a_{k}}:1\le k\le j;\begin{matrix}<br>k &amp; even \\<br>\end{matrix} \right)$。例如，对于向量$a_{1}^{5}=\left( 5,4,6,2,1 \right)$，有$a_{2}^{4}=\left( 4,6,2 \right)$，$a_{1,e}^{5}=\left( 4,2 \right)$，$a_{1,o}^{4}\left( 5,6 \right)$。全零向量则记为$0_{1}^{N}$。</p><p>在此所讨论的向量、矩阵的运算均是在二元域上的运算，即GF（2）。记$\oplus $为模2加，记$\otimes $为克罗内克积（Kronecker Power）。记${A^{\otimes n}}$表示$A$的$n$次克罗内克积，有递归式${A^{\otimes n}}=A\otimes {A^{\otimes \left( n-1 \right)}},n\ge 1$，并且定义${A^{\otimes 0}}=\left[ 1 \right]$。</p><p>记$\left| A \right|$表示集合$A$中元素的个数。记${1_{A}}$表示集合$A$的指示函数，若$x\in A$，则${1_{A\left( x \right)}}=1$；若$x\notin A$，则${1_{A\left( x \right)}}=0$。</p><h1 id="信道极化"><a href="#信道极化" class="headerlink" title="信道极化"></a>信道极化</h1><p>信道极化分为两个阶段：信道联合阶段（Channel Combining）和信道分裂（Channel Splitting）阶段。</p><h2 id="信道联合"><a href="#信道联合" class="headerlink" title="信道联合"></a>信道联合</h2><p>在这一阶段，联合B-DMC $W$的$N$个独立副本，通过递归方式产生一个向量信道${W_{N}}:{X^{N}}\to {Y^{N}}$，其中$N$为2的幂次$N={2^{n}},n\ge 0$。递归开始于第0级（$n=0$），只使用$W$的1个副本，并定义${W_{1}}\triangleq W$。第1级（$n=1$）递归联合了2个独立副本，如图1所示，得到向量信道${W_{2}}:{X^{2}}\to {Y^{2}}$，其转移概率为</p><script type="math/tex;mode=display">{W_{2}}\left( {y_{1}},{y_{2}}|{u_{1}},{u_{2}} \right)=W\left( {y_{1}}|{u_{1}}\oplus {u_{2}} \right)W\left( {y_{2}}|{u_{2}} \right)</script><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170305/175817308.png" title="图 1 信道${W_{2}}$"></p><p>第2级（$n=0$）递归如图2所示，联合信道${W_{2}}$的2个独立副本得到信道${W_{4}}:{X^{4}}\to {Y^{4}}$，其转移概率为</p><script type="math/tex;mode=display">{W_{4}}\left( y_{1}^{4}|u_{1}^{4} \right)={W_{2}}\left( y_{1}^{2}|{u_{1}}\oplus {u_{2}},{u_{3}}\oplus {u_{4}} \right){W_{2}}\left( y_{3}^{4}|{u_{2}},{u_{4}} \right)</script><p>在图2中，${R_{4}}$是完成从$\left( {s_{1}},{s_{2}},{s_{3}},{s_{4}} \right)$到$v_{1}^{4}=\left( {s_{1}},{s_{3}},{s_{2}},{s_{4}} \right)$的置换操作（排序）。从信道${W_{4}}$的输入${W^{4}}$的输入的映射$u_{1}^{4}\to x_{1}^{4}$可用公式表示为$x_{1}^{4}=u_{1}^{4}{G_{4}}$，${G_{4}}=\left[ \begin{matrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>1 &amp; 0 &amp; 1 &amp; 0 \\<br>1 &amp; 1 &amp; 0 &amp; 0 \\<br>1 &amp; 1 &amp; 1 &amp; 1 \\<br>\end{matrix} \right]$。因此${W_{4}}$和${W^{4}}$的转移概率有关系式${W_{4}}\left( y_{1}^{4}|u_{1}^{4} \right)={W^{4}}\left( y_{1}^{4}|u_{1}^{4}{G_{4}} \right)$。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170305/191031392.png" title="图 2 信道${W_{4}}$"></p><p>图3所示为递归结构的一般形式。${W_{N/{2}\;}}$的2个独立副本联合产生信道${W_{N}}$。输入向量$u_{1}^{N}$进入信道${W_{N}}$，首先被转换为$s_{1}^{N}$：${s_{2i-1}}={u_{2i-1}}\oplus {u_{2i}}$，${s_{2i}}={u_{2i}}$，$1\le i\le {N}/{2}\;$。${R_{N}}$表示比特反转排序操作，输入为$s_{1}^{N}$，输出为$v_{1}^{N}=\left( {s_{1}},{s_{3}},…,{s_{N-1}},{s_{2}},{s_{4}},…,{s_{N}} \right)$。$v_{1}^{N}$则成为2个${W_{N/{2}\;}}$独立副本的输入。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170305/192049297.png" title="图 3 信道${W_{N}}$的递归结构"></p><p>映射$u_{1}^{N}\to v_{1}^{N}$是二元域GF（2）上的线性变换。$u_{1}^{N}\to x_{1}^{N}$是由综合信道${W_{N}}$的输入到原始信道${W^{N}}$的输入的映射，其映射过程也是线性变换。因此有$x_{1}^{N}=u_{1}^{N}{G_{N}}$。称${G_{N}}$为$N$维生成矩阵。信道${W_{N}}$和${W^{N}}$的转移概率有如下关系：</p><script type="math/tex;mode=display">{W_{N}}\left( y_{1}^{N}|u_{1}^{N} \right)={W^{N}}\left( y_{1}^{N}|u_{1}^{N}{G_{N}} \right)</script><p>其中$y_{1}^{N}\in {Y^{N}},u_{1}^{N}\in {X^{N}}$。</p><h2 id="信道分裂"><a href="#信道分裂" class="headerlink" title="信道分裂"></a>信道分裂</h2><p>这是信道极化的第二阶段。将信道联合构成的综合信道${W_{N}}$分裂为$N$个二进制输入的坐标信道（Coordinate Channels）$W_{N}^{\left( i \right)}:X\to {Y^{N}}\times {X^{i-1}},1\le i\le N$，定义其转移概率为</p><script type="math/tex;mode=display">W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|{u_{i}} \right)\triangleq \sum\limits_{u_{i+1}^{N}\in {X^{N-i}}}{\frac{1}{2^{N-1}}{W_{N}}\left( y_{1}^{N}|u_{1}^{N} \right)}</script><p>其中$\left( y_{1}^{N},u_{1}^{i-1} \right)$表示$W_{N}^{\left( i \right)}$的输出，而${u_{i}}$表示$W_{N}^{\left( i \right)}$的输入。</p><h2 id="信道极化定理"><a href="#信道极化定理" class="headerlink" title="信道极化定理"></a>信道极化定理</h2><p><strong>定理1</strong>：对任意B-DMC $W$与任意$\delta \in \left( 0,1 \right)$，当$N$以2的幂次趋近于无穷大时，极化信道$W_{N}^{\left( i \right)}$中，满足$I\left( W_{N}^{\left( i \right)} \right)\in \left( 1-\delta ,1 \right]$的信道数占总信道数$N$的比例趋于$I\left( W \right)$；满足$I\left( W_{N}^{\left( i \right)} \right)\in \left[ 0,\delta \right)$的信道所占的比例趋于$1-I\left( W \right)$。</p><p><strong>定理2</strong>：对任意B-DMC $W$，$I\left( W \right)&gt;0$，且对任意$R&lt;I\left( W \right)$，存在一个序列集合${A_{N}}\subset \left\{ 1,…,N \right\},N\in \left\{ 1,2,…,{2^{n}},… \right\}$，对所有$i\in {A_{N}}$有$\left| {A_{N}} \right|\ge NR$且$Z\left( W_{N}^{\left( i \right)} \right)\le O\left( {N^{-5/{4}\;}} \right)$。</p><h1 id="极化编码"><a href="#极化编码" class="headerlink" title="极化编码"></a>极化编码</h1><p>利用极化现象构建的编码可以达到对称容量$I\left( W \right)$，是为极化编码（Polar Coding）。极化编码的基本思想是：只在$Z\left( W_{N}^{\left( i \right)} \right)$近于0的坐标信道$W_{N}^{\left( i \right)}$上发送数据比特。极化码具有一般的二元线性分组码的基本编码要素，因而可以通过显示地写出其生成矩阵来完成编码：</p><script type="math/tex;mode=display">x_{1}^{N}=u_{1}^{N}{G_{N}}</script><p>其中$u_{1}^{N}$为待编码比特序列，$x_{1}^{N}$为编码后的比特序列，${G_{N}}$为生成矩阵，码长为$N={2^{n}}$。</p><h2 id="构造生成矩阵"><a href="#构造生成矩阵" class="headerlink" title="构造生成矩阵"></a>构造生成矩阵</h2><p>生成矩阵表示为</p><script type="math/tex;mode=display">{G_{N}}\text{=}{B_{N}}{F^{\otimes n}}</script><p>其中${F^{\otimes n}}$表示对矩阵$F=\left[ \begin{matrix}<br>1 &amp; 0 \\<br>1 &amp; 1 \\<br>\end{matrix} \right]$的$n$次克罗内克积，有递归式${F^{\otimes n}}\text{=}F\otimes {F^{\otimes \left( n-1 \right)}}$。${B_{N}}$是排序矩阵，用以完成比特反序重排操作。所有比特反序重排，就是将每个原序列的十进制序号$i\in \left\{ 1,2,…,N \right\}$按二进制表示为$\left( i-1 \right)\to \left( {b_{n}},{b_{n-1}},…,{b_{1}} \right)$，其中${b_{n}}$为最高有效位；再将该二进制序列反序，得到$\left( {b_{1}},{b_{2}},…,{b_{n}} \right)$；最后以${b_{1}}$为最高有效位重新按十进制表示成$\left( {b_{1}},{b_{2}},…,{b_{n}} \right)\to \left( j-1 \right)$，令输出序列的第$j$个元素取值为原序列的第$i$个元素。${B_{N}}$的递归式定义为</p><script type="math/tex;mode=display">{B_{N}}={R_{N}}\left( {I_{2}}\otimes {B_{N/{2}\;}} \right)</script><p>其中${I_{2}}$为2维单位阵，${B_{2}}={I_{2}}$；矩阵${R_{N}}$为置换矩阵，对输入序列完成奇序元素和偶序元素的分离，即先排奇序元素，再排偶序元素，其作为效果如下</p><script type="math/tex;mode=display">\left( {u_{1}},{u_{2}},{u_{3}},{u_{4}},...,u{}_{N} \right)\times {R_{N}}=\left( {u_{1}},{u_{3}},{u_{5}},...,{u_{N-1}},{u_{2}},{u_{4}},{u_{6}},...,{u_{N}} \right)</script><h2 id="选择消息比特位置"><a href="#选择消息比特位置" class="headerlink" title="选择消息比特位置"></a>选择消息比特位置</h2><p>到目前，已经知道在给定序列$u_{1}^{N}$的情况下如何构造极化码，实际编码中的$u_{1}^{N}$并不是事先给定的。现在来考虑如何确定$u_{1}^{N}$中哪些比特位置用于传输消息比特，哪些比特位置用于传输冻结比特。</p><p>一般地，对于码长为$N$，消息比特数为$K$的待编码序列，通过以下步骤获得消息比特的位置：</p><ul><li>step1：计算各个分裂信道$W_{N}^{\left( i \right)}$的错误概率；</li><li>step2：将step1得到的$N$个错误概率值从小到大排序；</li><li>step3：选择错误概率最小的$K$个分裂信道用于传输消息比特，其余分裂信道传输冻结比特。</li></ul><p>那么如果计算各个子信道的错误概率？Arikan针对BEC给出的方法是计算巴氏参数</p><script type="math/tex;mode=display">Z\left( W_{N}^{\left( i \right)} \right)=\sum\limits_{y_{1}^{N}\in {Y^{N}}}{\sum\limits_{u_{1}^{i-1}\in {X^{i-1}}}{\sqrt{W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|0 \right)W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|1 \right)}}}</script><p>选择$Z\left( W_{N}^{\left( i \right)} \right)$近于0的子信道传输消息比特。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文首先介绍了Polar Code的预备知识，如对称容量、巴氏参数以及所涉及的数学符号的表示。其次介绍了信道极化的两个阶段：信道联合与信道分裂。最后阐述了Polar Code的编码过程：通过构造生成矩阵获得${G_{N}}$，通过计算各个分裂子信道的错误概率用以判断消息比特位置从而获得$u_{1}^{N}$；两者相乘$u_{1}^{N}{G_{N}}$即为Polar Code。</p><p>极化码是一种线性分组码，通过构造生成矩阵而获得编码。只要给定码长$N$，编译码结构就唯一确定。极化码基于信道极化现象，做到了扬长而避短。在最可靠的子信道上传输消息比特是为扬长，在最不可靠的子信道上传输冻结比特是为避短。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Arikan E. Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels[J]. IEEE Transactions on Information Theory, 2008, 55(7):3051-3073.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://marshallcomm.github.io/2017/03/01/polar-code-1-summary/&quot;&gt;《Polar Code（1）概述》&lt;/a&gt;中建立了Polar Code初步印象，本文将详细阐述Polar Code编码原理。Polar Code是通过引入信道极化概念而构建的。信道极化分为两个阶段，分别是信道联合和信道分裂。通过信道的联合与分裂，各个子信道的对称容量将呈现两级分化的趋势：随着码长（也就是联合信道数）$N$的增加，一部分子信道的容量趋于1，而其余子信道的容量趋于0。Polar Code正是利用这一信道极化的现象，在容量趋于1的$K$个子信道上传输消息比特，在其余子信道上传输冻结比特（即收发双方已知的固定比特，通常设置为全零）。由此构成的编码即为Polar Code，码率为${K}/{N}\;$。&lt;/p&gt;&lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;p&gt;一个二进制输入离散无记忆信道（B-DMC）可表示为$W:X\to Y$，$X$是输入符号集合，$Y$是输出符号集合，转移概率为$W\left( y|x \right),x\in X,y\in Y$。由于信道是二进制输入，集合$X=\left\{ 0,1 \right\}$；$Y$和$W\left( y|x \right)$是任意值。对信道$W$的$N$次使用后的信道可表示为${W^{N}}$，则信道${W^{N}}:{X^{N}}\to {Y^{N}}$的转移概率为${W^{N}}\left( y_1^{N}|x_{1}^{N} \right)=\prod\nolimits_{i=1}^{N}{W\left( y|x \right)}$。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Polar Code" scheme="http://yoursite.com/tags/Polar-Code/"/>
    
  </entry>
  
  <entry>
    <title>Polar Code（1）概述</title>
    <link href="http://yoursite.com/2017/03/01/polar-code-1-summary/"/>
    <id>http://yoursite.com/2017/03/01/polar-code-1-summary/</id>
    <published>2017-03-01T08:23:13.000Z</published>
    <updated>2017-03-05T14:59:52.179Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --><p>2016年11月18日，在美国内华达州里诺进行的3GPP RAN1 #87次会议，最终确定<strong>Polar Code</strong>作为5G <strong>eMBB</strong>（增强移动宽带）场景下<strong>控制信道</strong>编码方案。</p><p>2008年，Erdal Arikan在国际信息论ISIT会议上首次提出了<strong>信道极化（Channel Polarization）</strong>的概念；2009年在“IEEE Transaction on Information Theory”期刊上发表了一篇长达23页的论文更加详细地阐述了信道极化，并基于信道极化给出了一种新的编码方式，名称为<strong>极化码（Polar Code）</strong>。极化码具有确定性的构造方法，并且是已知的唯一一种能够被严格证明“达到”信道容量的信道编码方法。</p><a id="more"></a><p>从代数编码和概率编码的角度来说，极化码具备了两者各自的特点。首先，只要给定编码长度，极化码的编译码结构就唯一确定了，而且可以通过生成矩阵的形式完成编码过程，这一点和代数编码的常见思维是一致的。其次，极化码在设计时并没有考虑最小距离特性，而是利用了<strong>信道联合（Channel Combination）与信道分裂（Channel Splitting）</strong>的过程来选择具体的编码方案，而且在译码时也是采用概率算法，这一点比较符合概率编码的思想。</p><p>对于长度为$N={2^{n}}$（$n$为任意正整数）的极化码，它利用信道$W$的N个独立副本，进行信道联合和信道分裂，得到新的N个分裂之后的信道$\left\{ W_{N}^{\left( 1 \right)},W_{N}^{\left( 2 \right)},…,W_{N}^{\left( N \right)} \right\}$。随着码长N的增加，分裂之后的信道将向两个极端发展：其中一部分分裂信道会趋近于完美信道，即信道容量趋近于1的无噪声信道；而另一部分分裂信道会趋近于完全噪声信道，即信道容量趋近于0的信道。假设原信道$W$的二进制输入对称容量记作$I\left(W\right)$，那么当码长N趋近于无穷大时，信道容量趋近于1的分裂信道比例约为$K=N\times I\left( W \right)$，而信道容量趋近于0的比例约为$N\times \left( 1-I\left( W \right) \right)$。对于信道容量为1的可靠信道，可以直接放置消息比特而不采用任何编码，即相当于编码速率为$R=1$；而对于信道容量为0的不可靠信道，可以放置发送端和接收端都事先已知的冻结比特，即相当于编码速率为$R=0$。那么当码长$N\to \infty $时，极化码的可达编码速率$R=N\times I\left(W\right)/N=I\left(W\right)$，即在理论上，极化码可以被证明是可达信道容量的。</p><p>在极化码编码时，首先要区分出N个分裂信道的可靠程度，即哪些属于可靠信道，哪些属于不可靠信道。对各个极化信道的可靠性进行度量常用的有三种方法：<strong>巴氏参数</strong>（Bhattacharyya Parameter）法、<strong>密度进化</strong>（Density Evolution，DE）法和<strong>高斯近似</strong>（Gaussian Approximation）法：</p><ol><li>最初，极化码采用巴氏参数$Z\left( W \right)$来作为每个分裂信道的可靠性度量，$Z\left( W \right)$越大表示信道的可靠程度越低。当信道$W$是二元删除信道（Binary Erasure Channel，BEC）时，每个$Z\left( W_{N}^{\left( i \right)} \right)$都可以采用递归的方式计算出来，复杂度为$O\left( N\log N \right)$。然而，对于其他信道，如二进制输入对称信道（Binary-input Symmeric Channel，BSC）或者二进制输入加性高斯白噪声信道（Binary-input Additive White Gaussian Channel，BAWGNC）并不存在准确的能够计算$Z\left( W_{N}^{\left( i \right)} \right)$的方法。</li><li>因此，Mori等人提出了一种采用密度进化方法跟踪每个子信道概率密度函数（Probability Density Function，PDF），从而估计每个子信道错误概率的方法。这种方法适用于所有类型的二进制输入离散无记忆信道（Binary-input Discrete Memoryless Channel，B-DMC）信道。</li><li>在大多数研究场景下，信道编码的传输信道模型均为BAWGNC信道。在BAWGNC信道下，可以将密度进化中的对数似然比（Likelihood Rate，LLR）的概率密度函数用一族方差为均值2倍的高斯分布来近似，从而简化成了对一维均值的计算，大大降低计算量，这种对DE的简化计算即为高斯近似。</li></ol><p>参考文献：<br>[1] Arikan E. Channel polarization: A method for constructing capacity-achieving codes[C]// IEEE International Symposium on Information Theory. IEEE, 2008:1173-1177.<br>[2] Arikan E. Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels[J]. IEEE Transactions on Information Theory, 2008, 55(7):3051-3073.<br>[3] 陈凯. 极化编码理论与实用方案研究[D]. 北京邮电大学, 2014.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;2016年11月18日，在美国内华达州里诺进行的3GPP RAN1 #87次会议，最终确定&lt;strong&gt;Polar Code&lt;/strong&gt;作为5G &lt;strong&gt;eMBB&lt;/strong&gt;（增强移动宽带）场景下&lt;strong&gt;控制信道&lt;/strong&gt;编码方案。&lt;/p&gt;&lt;p&gt;2008年，Erdal Arikan在国际信息论ISIT会议上首次提出了&lt;strong&gt;信道极化（Channel Polarization）&lt;/strong&gt;的概念；2009年在“IEEE Transaction on Information Theory”期刊上发表了一篇长达23页的论文更加详细地阐述了信道极化，并基于信道极化给出了一种新的编码方式，名称为&lt;strong&gt;极化码（Polar Code）&lt;/strong&gt;。极化码具有确定性的构造方法，并且是已知的唯一一种能够被严格证明“达到”信道容量的信道编码方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Polar Code" scheme="http://yoursite.com/tags/Polar-Code/"/>
    
  </entry>
  
  <entry>
    <title>开宗明义</title>
    <link href="http://yoursite.com/2017/03/01/hello-world/"/>
    <id>http://yoursite.com/2017/03/01/hello-world/</id>
    <published>2017-03-01T01:51:33.000Z</published>
    <updated>2017-03-01T02:20:18.355Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --><p>首篇博文，开宗明义。</p><p>这是一个无线通信技术博客，主要用于记录自己在工作中对无线通信知识的梳理、总结或学习笔记。博客内容涉及但不限于5G技术预研、NB-IOT物理层算法以及LTE物理层算法。</p><p>工作中每个研究阶段有每个阶段的任务，研究完一个方向，继而转入下一个新方向。若不对这些知识碎片及时整理，时间一长难免淡忘。若能坚持写技术博客，不断完成对新知识的梳理和对旧知识的回顾是大有裨益的。故开博以记之。</p><p>Weibo: @Marshall_MS<br>Email: marshallcomm@163.com</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 05 2017 23:00:17 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;首篇博文，开宗明义。&lt;/p&gt;&lt;p&gt;这是一个无线通信技术博客，主要用于记录自己在工作中对无线通信知识的梳理、总结或学习笔记。博客内容涉及但不限于5G技术
    
    </summary>
    
    
  </entry>
  
</feed>
