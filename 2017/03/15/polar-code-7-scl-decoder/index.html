<!-- build time:Wed Aug 23 2017 13:09:41 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="Polar Code,"><link rel="alternate" href="/atom.xml" title="Marshall" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="前言Polar Code在码长趋于无穷时，信道极化才越完全。但在有限码长下，由于信道极化并不完全，依然会存在一些信息比特无法被正确译码。当前面$i-1$个信息比特的译码中发生错误之后，由于SC译码器在对后面的信息比特译码时需要用到之前的信息比特的估计值，这就会导致较为严重的错误传递。SC译码算法是一种贪婪算法，对码树的每一层仅仅搜索到最优路径就进行下一层，所以无法对错误进行修改。SCL译码算法就是"><meta property="og:type" content="article"><meta property="og:title" content="Polar Code（7）SCL译码算法"><meta property="og:url" content="https://marshallcomm.github.io/2017/03/15/polar-code-7-scl-decoder/index.html"><meta property="og:site_name" content="Marshall"><meta property="og:description" content="前言Polar Code在码长趋于无穷时，信道极化才越完全。但在有限码长下，由于信道极化并不完全，依然会存在一些信息比特无法被正确译码。当前面$i-1$个信息比特的译码中发生错误之后，由于SC译码器在对后面的信息比特译码时需要用到之前的信息比特的估计值，这就会导致较为严重的错误传递。SC译码算法是一种贪婪算法，对码树的每一层仅仅搜索到最优路径就进行下一层，所以无法对错误进行修改。SCL译码算法就是"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/205026503.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/205500502.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/221254645.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/221926567.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/222254421.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/222502055.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/223032922.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170427/134154868.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170427/134331096.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170427/135823406.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170427/140245285.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170427/140423071.jpg"><meta property="og:updated_time" content="2017-08-04T09:03:21.203Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Polar Code（7）SCL译码算法"><meta name="twitter:description" content="前言Polar Code在码长趋于无穷时，信道极化才越完全。但在有限码长下，由于信道极化并不完全，依然会存在一些信息比特无法被正确译码。当前面$i-1$个信息比特的译码中发生错误之后，由于SC译码器在对后面的信息比特译码时需要用到之前的信息比特的估计值，这就会导致较为严重的错误传递。SC译码算法是一种贪婪算法，对码树的每一层仅仅搜索到最优路径就进行下一层，所以无法对错误进行修改。SCL译码算法就是"><meta name="twitter:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170315/205026503.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://marshallcomm.github.io/2017/03/15/polar-code-7-scl-decoder/"><title>Polar Code（7）SCL译码算法 | Marshall</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Marshall</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Comm. Tech. Blog</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://marshallcomm.github.io/2017/03/15/polar-code-7-scl-decoder/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Marshall"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Marshall"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Polar Code（7）SCL译码算法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T20:40:17+08:00">2017-03-15 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Polar-Code/" itemprop="url" rel="index"><span itemprop="name">Polar Code</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/03/15/polar-code-7-scl-decoder/#SOHUCS" itemprop="discussionUrl"><span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/03/15/polar-code-7-scl-decoder/" itemprop="commentsCount"></span> </a><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><br>Polar Code在码长趋于无穷时，信道极化才越完全。但在有限码长下，由于信道极化并不完全，依然会存在一些信息比特无法被正确译码。当前面$i-1$个信息比特的译码中发生错误之后，由于SC译码器在对后面的信息比特译码时需要用到之前的信息比特的估计值，这就会导致较为严重的错误传递。SC译码算法是一种贪婪算法，对码树的每一层仅仅搜索到最优路径就进行下一层，所以无法对错误进行修改。SCL译码算法就是对SC算法的改进。但在SCL之前，先来看看SC译码算法的码树表示。</p><a id="more"></a><h1 id="SC译码算法的码树表示"><a href="#SC译码算法的码树表示" class="headerlink" title="SC译码算法的码树表示"></a>SC译码算法的码树表示</h1><p><br>根据极化码在SC译码下各个比特判决之间的依赖关系，能够构造一颗码树$\Gamma =\left( \varepsilon ,V \right)$，其中$\varepsilon $和$V$分别表示码树中的边和节点集合。定义节点的深度为该节点到根节点的最短路径长度，对于一个码长为$N$的极化码，其码树节点集合$V$能够按照深度$d$划分成$N+1$个子集，记作${ {V}_{d}}$，其中$d=0,1,…,N$。特别地，${ {V}_{0}}$仅包含根节点，即$\left| { {V}_{0}} \right|=1$。除了叶节点（即$d=N$时），码树$\Gamma $中的每一个节点$v\in { {V}_{d}}$均分别通过两条标记着0、1的边与两个${ {V}_{d+1}}$中的后继节点相连。某一个节点$v$所对应的序列$u_{1}^{d}$的值定义为从根节点开始到达该节点$v$所需经过的各个边的标记序列。例如，若某一个节点$v$表示了序列$u_{1}^{i}$，则其左、右后继节点分别代表了路径$\left( u_{1}^{i},u_{1}^{i+1}=0 \right)$与$\left( u_{1}^{i},u_{1}^{i+1}=1 \right)$。于是，从根节点到每一个深度为$d$的节点$v\in { {V}_{d}}$的路径，均对应了一种$u_{1}^{d}$可能的取值，由于信源序列为二进制比特序列，所以$\left| { {V}_{d}} \right|={ {2}^{d}}$。定义连接着深度为$i-1$和$i$的节点的边所构成的集合为第$i$层边，记作${ {\varepsilon }_{i}}$。显然，对任意$i\in \left\{ 1,2,…,N \right\}$，有$\left| { {\varepsilon }_{i}} \right|={ {2}^{i}}$。从根节点到任何一个节点所形成的路径，均对应一个路径度量值（PM）。值得注意的是，该码树结构仅与码长$N$有关。极化码译码码树实质上是一个满二叉树，因此译码过程也就是在满二叉树上寻找合适的路径。如图1所示，给出了一个当$N=4$时极化码码树的示例，各节点旁的数字指示了对应的转移概率，在每个节点处选择转移概率最大的路径，最终译码序列为$\hat{u}_{1}^{N}=\left[ \begin{matrix}<br>0 &amp; 0 &amp; 1 &amp; 1 \\<br>\end{matrix} \right]$。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/205026503.jpg" title="图 1 码长为4的极化码译码码树"></p><h1 id="SCL译码算法"><a href="#SCL译码算法" class="headerlink" title="SCL译码算法"></a>SCL译码算法</h1><p><br>针对SC译码算法的缺点，一个直接的改进方案是，增加每一层路径搜索后允许保留的候选路径数量，从仅允许选择“最好的一条路径进行下一步扩展”改为“最大允许选择最好的 条路径进行下一步扩展”，其中$L\ge 1$。与SC算法一样，改进的算法依然从码树根节点开始，逐层依次向叶子节点层进行路径搜索。不同的是，每一层扩展后，尽可能多地保留后继路径（每一层保留的路径数不大于$L$）。完成一层的路径扩展后，选择路径度量值（Path Metrics，PM）最小的$L$条，保存在一个列表中，等待进行下一层的扩展。因此称该算法为<strong>串行抵消列表（Successive Cancellation List，SCL）译码算法</strong>，并称参数$L$为<strong>搜索宽度</strong>。当$L=1$时，SCL译码算法退化为SC译码算法；当$L\ge { {2}^{K}}$时，SCL译码等价于最大似然译码。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><br>现在思考一个问题：如图2所示，当Polar Code编译码结构用“蝶形图”表示时，在译码时只需要在每个节点处计算相应的对数似然比，从右到左依次计算，并最终得到$L_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1} \right)$，若LLR值为非负则判决${ {\hat{u}}_{i}}=0$，否则判决${ {\hat{u}}_{i}}=1$。一共有$N\log N$个节点，因此相应地也要计算$N\log N$个LLR。对于图2来说这一过程没有任何问题。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/205500502.jpg" title="图 2 Polar Code编译码结构蝶形图表示"></p><p>现在转换思路，将译码结构用二叉树表示，一个LLR值指示了每个节点两条支路上的转移概率的比值关系。如果像图1那样，每条支路就用转移概率来表征，向左是发送为比特0的转移概率，向右是发送为比特1的转移概率。当然这样也可以，对于SC译码来说，图1使用转移概率和图2使用对数似然比实际上是等价的。但随着码长的增加，转移概率函数的数值会越来越小，译码器存在着下溢的风险，所以通常不直接使用转移概率。由于SC译码过程实质上是二值判决，因此通常还是要采用转移概率的对数似然比。</p><p>现在可以明确两点：一是使用对数似然比，二是在满二叉树上使用对数似然比。但仍然存在的问题是：SC算法实际上是SCL算法的特例，即搜索宽度$L=1$的情况；对于$L\ge 2$的情况，单单依靠LLR是无法在$2L$个后继节点中挑选$L$个最优节点作为后继译码路径的。这就需要在LLR的基础上对$2L$条路径度量值进行计算，以便可以实现在对数似然域上的SCL译码算法。因此需要明确的第三点就是：重新定义路径度量值（PM）。</p><h2 id="路径度量值"><a href="#路径度量值" class="headerlink" title="路径度量值"></a>路径度量值</h2><p><br>在SCL译码过程中，存在$L$条路径同时进行译码搜索，对于任意一条路径$l\in \left\{ 1,2,…,L \right\}$以及任意发送比特${ {u}_{i}}$（$i\in \left\{ 1,2,…,N \right\}$），其对应的路径度量值定义如下：</p><script type="math/tex;mode=display">\begin{align}
PM_{l}^{\left( i \right)}\triangleq \sum\limits_{j=1}^{i}{\ln \left( 1+\exp \left( -\left( 1-2{ { {\hat{u}}}_{j}}\left[ l \right] \right)\cdot L_{N}^{\left( j \right)} \right) \right)}
\end{align}</script><p>其中，$L_{N}^{\left( j \right)}\left[ l \right]=\ln \frac{W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}\left[ l \right]|0 \right)}{W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}\left[ l \right]|1 \right)}$。</p><p>如果发送端所有信息比特在$\left\{ 0,1 \right\}$上均匀分布，那么对于任意两条不同路径${ {l}_{1}},{ {l}_{2}}\in \left\{ 1,2,…,L \right\}$，当且仅当$PM_{ { {l}_{1}}}^{\left( i \right)}&gt;PM_{ { {l}_{2}}}^{\left( i \right)}$成立时，有如下关系成立：</p><script type="math/tex;mode=display">\begin{align}
W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}\left[ { {l}_{1}} \right]|\hat{u}_{1}^{i}\left[ { {l}_{1}} \right] \right)<W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}\left[ { {l}_{2}} \right]|\hat{u}_{1}^{i}\left[ { {l}_{2}} \right] \right)
\end{align}</script><p>由上式可见，路径对应的转移概率越大，路径度量值越小。基于这种关系就完全可以在对数似然比上对$2L$条路径进行挑选。式（1）可以近似表示为</p><script type="math/tex;mode=display">\begin{align}
\nonumber PM_{l}^{\left( i \right)}\approx \left\{ \begin{matrix}
   PM_{l}^{\left( i-1 \right)},\ \ if\ { { {\hat{u}}}_{i}}\left[ l \right]=\delta \left( L_{N}^{\left( i \right)}\left[ l \right] \right)  \\
   PM_{l}^{\left( i-1 \right)}+\left| L_{N}^{\left( i \right)}\left[ l \right] \right|,\ \ if\ { { {\hat{u}}}_{i}}\left[ l \right]\ne \delta \left( L_{N}^{\left( i \right)}\left[ l \right] \right)  \\
\end{matrix} \right.
\end{align}</script><p>但考虑译码过程中包含了信息比特和冻结比特，因此上式可以改写为</p><script type="math/tex;mode=display">PM_{l}^{\left( i \right)}=\left\{ \begin{align}
  \nonumber & PM_{l}^{\left( i-1 \right)}\ \ ,\ if\ { {u}_{i}}\ is\ \text{information or frozen bit}\ and\text{ }{ { {\hat{u}}}_{i}}\left[ l \right]=\delta \left( L_{N}^{\left( i \right)}\left[ l \right] \right) \\ 
 & PM_{l}^{\left( i-1 \right)}+\left| L_{N}^{\left( i \right)}\left[ l \right] \right|,\ if\ { {u}_{i}}\ is\ \text{information or frozen bit}\ and\text{ }{ { {\hat{u}}}_{i}}\left[ l \right]\ne \delta \left( L_{N}^{\left( i \right)}\left[ l \right] \right) \\ 
 \nonumber & +\infty \ \ ,\ if\ { {u}_{i}}\ is\ \text{frozen bit}\ and\ \text{incorrect value} \\ 
\end{align} \right.</script><p>其中$\delta \left( x \right)=\frac{1}{2}\left( 1-sign\left( x \right) \right)$，$PM_{l}^{\left( 0 \right)}=0$。对于信息比特的判决有</p><script type="math/tex;mode=display">\begin{align}
{ {\hat{u}}_{i}}=\delta \left( L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right) \right)
\end{align}</script><h1 id="SCL译码示例"><a href="#SCL译码示例" class="headerlink" title="SCL译码示例"></a>SCL译码示例</h1><p><br>下面仍然以<a href="https://marshallcomm.github.io/2017/03/13/polar-code-6-sc-decoder/">《Polar Code（6）SC译码算法》</a>中的SC译码的例子为例来说明SCL算法的具体实现过程。给定发送端原始比特序列$u_{1}^{4}=\left( \begin{matrix}<br>{ {u}_{1}} &amp; { {u}_{2}} &amp; { {u}_{3}} &amp; { {u}_{4}} \\<br>\end{matrix} \right)=\left( \begin{matrix}<br>0 &amp; 0 &amp; 0 &amp; 0 \\<br>\end{matrix} \right)$，其中${ {u}_{1}}$为冻结比特，$u_{2}^{4}$为信息比特。经过Polar编码以后通过AWGN信道传输。假设接收端已知各子信道对数似然比$L_{1}^{\left( 1 \right)}\left( y_{1}^{4} \right)=\left[ \begin{matrix}<br>1.5 &amp; 2 &amp; -1 &amp; 0.5 \\<br>\end{matrix} \right]$。</p><font color="#FF0000">每一条路径都拥有自己的一套LLR值，每一条路径的PM都要根据各自路径上的LLR值计算。以a、b、c、d表示路径1、路径2、路径3、路径4。为了便于说明SCL译码过程，PM值直接标注在示意图上，LLR值则用一个向量来表示。</font><h2 id="搜索第一层"><a href="#搜索第一层" class="headerlink" title="搜索第一层"></a>搜索第一层</h2><h3 id="计算第1个比特相关的LLR"><a href="#计算第1个比特相关的LLR" class="headerlink" title="计算第1个比特相关的LLR"></a>计算第1个比特相关的LLR</h3><p><br><script type="math/tex">L_{4}^{\left( 1 \right)}\left( y_{1}^{4} \right)=f\left( L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right),L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right) \right)</script></p><p>其中，$L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right)$和$L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right)$递归地计算为</p><script type="math/tex;mode=display">L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right)=f\left( L_{1}^{\left( 1 \right)}\left( { {y}_{1}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{2}} \right) \right)=f\left( 1.5,2 \right)=1.06</script><script type="math/tex;mode=display">L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right)=f\left( L_{1}^{\left( 1 \right)}\left( { {y}_{3}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{4}} \right) \right)=f\left( -1,0.5 \right)=-0.23</script><p>从而，<script type="math/tex">L_{4}^{\left( 1 \right)}\left( y_{1}^{4} \right)=f\left( 1.06,-0.23 \right)=-0.11</script>。</p><p><strong>建立向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   -0.11 & -0.11  \\
\end{matrix} \right]</script><h3 id="计算候选路径的度量值"><a href="#计算候选路径的度量值" class="headerlink" title="计算候选路径的度量值"></a>计算候选路径的度量值</h3><h4 id="a-0"><a href="#a-0" class="headerlink" title="a. 0"></a>a. 0</h4><p><br>$L_{4}^{\left( 1 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第1元素</font> ，即$L_{4}^{\left( 1 \right)}=-0.11$；比特估计值${ {\hat{u}}_{1}}=0$。</p><p>$\delta \left( L_{4}^{\left( 1 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -0.11 \right) \right)=1$。由于${ {u}_{1}}$是冻结比特，但${ {\hat{u}}_{1}}\ne \delta \left( L_{4}^{\left( 1 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( { { {\hat{u}}}_{1}}=0 \right)=PM_{1}^{\left( 0 \right)}+\left| L_{4}^{\left( 1 \right)} \right|=0+0.11=0.11</script><h4 id="b-1"><a href="#b-1" class="headerlink" title="b. 1"></a>b. 1</h4><p><br>$L_{4}^{\left( 1 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第2元素</font> ，即$L_{4}^{\left( 1 \right)}=-0.11$；比特估计值${ {\hat{u}}_{1}}=1$。</p><p>$\delta \left( L_{4}^{\left( 1 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -0.11 \right) \right)=1$。由于${ {u}_{1}}$是冻结比特，但此时${ {\hat{u}}_{1}}=1$显然取值错误，所以有</p><script type="math/tex;mode=display">PM\left( { { {\hat{u}}}_{1}}=1 \right)=\text{+}\infty</script><h4 id="路径扩展"><a href="#路径扩展" class="headerlink" title="路径扩展"></a>路径扩展</h4><p><br>如图3所示，由于搜索宽度已达到$L=2$，因此第1层的2条路径均保留。继续在下一层扩展，至$2L$条路径，再从中挑选$L$条。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/221254645.jpg" title="图 3 SCL译码算法在第1层的扩展"></p><h2 id="搜索第二层"><a href="#搜索第二层" class="headerlink" title="搜索第二层"></a>搜索第二层</h2><h3 id="计算第2个比特相关的LLR"><a href="#计算第2个比特相关的LLR" class="headerlink" title="计算第2个比特相关的LLR"></a>计算第2个比特相关的LLR</h3><p><br>分别计算$2L$条路径在第2层对应的LLR。</p><h4 id="a-00"><a href="#a-00" class="headerlink" title="a. 00"></a>a. 00</h4><p><br>比特估计值${ {\hat{u}}_{1}}=0$，所以有</p><script type="math/tex;mode=display">\nonumber \begin{align}
  & L_{4}^{\left( 2 \right)}\left( y_{1}^{4},{ { {\hat{u}}}_{1}} \right)=g\left( L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right),L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right),{ { {\hat{u}}}_{1}} \right)\text{=}g\left( 1.06,-0.23,0 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{0}}\times 1.06+\left( -0.23 \right) \\ 
 \nonumber & =0.83 \\ 
\end{align}</script><p><strong>重新建立向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ 0.83 \right]</script><h4 id="b-01"><a href="#b-01" class="headerlink" title="b. 01"></a>b. 01</h4><p><br>同上，$L_{4}^{\left( 2 \right)}\left( y_{1}^{4},{ { {\hat{u}}}_{1}} \right)=0.83$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   0.83 & 0.83  \\
\end{matrix} \right]</script><h4 id="c-10"><a href="#c-10" class="headerlink" title="c. 10"></a>c. 10</h4><p><br>比特估计值${ {\hat{u}}_{1}}=1$，所以有</p><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{4}^{\left( 2 \right)}\left( y_{1}^{4},{ { {\hat{u}}}_{1}} \right)=g\left( L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right),L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right),{ { {\hat{u}}}_{1}} \right)\text{=}g\left( 1.06,-0.23,1 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{1}}\times 1.06+\left( -0.23 \right) \\ 
 \nonumber & =-1.29 \\ 
\end{align}\</script><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   \begin{matrix}
   0.83 & 0.83  \\
\end{matrix} & -1.29  \\
\end{matrix} \right]</script><h4 id="d-11"><a href="#d-11" class="headerlink" title="d. 11"></a>d. 11</h4><p><br>同上，$L_{4}^{\left( 2 \right)}\left( y_{1}^{4},{ { {\hat{u}}}_{1}} \right)=-1.29$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   \begin{matrix}
   \begin{matrix}
   0.83 & 0.83  \\
\end{matrix} & -1.29  \\
\end{matrix} & -1.29  \\
\end{matrix} \right]</script><h3 id="计算候选路径的度量值-1"><a href="#计算候选路径的度量值-1" class="headerlink" title="计算候选路径的度量值"></a>计算候选路径的度量值</h3><p><br>由于在上一层已经扩展至$L$条路径，那么在这一层将会计算$2L$条路径的度量值，然后保留PM最小的$L$条路径，并且删除其余路径。</p><h4 id="a-00-1"><a href="#a-00-1" class="headerlink" title="a. 00"></a>a. 00</h4><p><br>$L_{4}^{\left( 2 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第1元素</font> ，即$L_{4}^{\left( 2 \right)}=0.83$；比特估计值${ {\hat{u}}_{2}}=0$。</p><p>$\delta \left( L_{4}^{\left( 2 \right)} \right)=\frac{1}{2}\left( 1-sign\left( 0.83 \right) \right)=0$。由于${ {u}_{2}}$为信息比特，且${ {\hat{u}}_{2}}=\delta \left( L_{4}^{\left( 2 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{2}=00 \right)=PM\left( { { {\hat{u}}}_{1}}=0 \right)=0.11</script><h4 id="b-01-1"><a href="#b-01-1" class="headerlink" title="b. 01"></a>b. 01</h4><p><br>$L_{4}^{\left( 2 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第2元素</font> ，即$L_{4}^{\left( 2 \right)}=0.83$；比特估计值${ {\hat{u}}_{2}}=1$。</p><p>$\delta \left( L_{4}^{\left( 2 \right)} \right)=\frac{1}{2}\left( 1-sign\left( 0.83 \right) \right)=0$。由于${ {u}_{2}}$为信息比特，且${ {\hat{u}}_{2}}\ne \delta \left( L_{4}^{\left( 2 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{2}=01 \right)=PM\left( { { {\hat{u}}}_{1}}=0 \right)+\left| L_{4}^{\left( 2 \right)} \right|\text{=0}\text{.11+}0.83=0.94</script><p>截止目前的扩展路径如图4所示。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/221926567.jpg" title="图 4 SCL译码算法在第2层的扩展"></p><h4 id="c-10-1"><a href="#c-10-1" class="headerlink" title="c. 10"></a>c. 10</h4><p><br>$L_{4}^{\left( 2 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第3元素</font> ，即$L_{4}^{\left( 2 \right)}=-1.29$；比特估计值${ {\hat{u}}_{2}}=0$。</p><p>$\delta \left( L_{4}^{\left( 2 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -1.29 \right) \right)=1$。由于${ {u}_{2}}$为信息比特，且${ {\hat{u}}_{2}}\ne \delta \left( L_{4}^{\left( 2 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{2}=10 \right)=PM\left( { { {\hat{u}}}_{1}}=1 \right)\text{+}L_{4}^{\left( 2 \right)}\text{=}+\infty +1.29\to +\infty</script><h4 id="d-11-1"><a href="#d-11-1" class="headerlink" title="d. 11"></a>d. 11</h4><p><br>$L_{4}^{\left( 2 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第4元素</font> ，即$L_{4}^{\left( 2 \right)}=-1.29$；比特估计值${ {\hat{u}}_{2}}=1$。</p><p>$\delta \left( L_{4}^{\left( 2 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -1.29 \right) \right)=1$。由于${ {u}_{2}}$为信息比特，且${ {\hat{u}}_{2}}=\delta \left( L_{4}^{\left( 2 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{2}=11 \right)=PM\left( { { {\hat{u}}}_{1}}=1 \right)\text{=}+\infty</script><p>截止目前的扩展路径如图5所示。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/222254421.jpg" title="图 5 SCL译码算法在第2层的扩展"></p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p><br>将已经计算出的$2L$路径按照PM值从小到大排序，对这$2L$条路径进行剪枝操作：保留$L$条PM值最小的路径，并且删掉其余路径。如图6所示，被保留的路径为红色，被剪枝的路径均已变成灰色。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/222502055.jpg" title="图 6 剪枝"></p><h2 id="搜索第三层"><a href="#搜索第三层" class="headerlink" title="搜索第三层"></a>搜索第三层</h2><p><br>分别计算 条路径在第3层对应的LLR。</p><h3 id="计算第3个比特相关的LLR"><a href="#计算第3个比特相关的LLR" class="headerlink" title="计算第3个比特相关的LLR"></a>计算第3个比特相关的LLR</h3><h4 id="a-000"><a href="#a-000" class="headerlink" title="a. 000"></a>a. 000</h4><p><br>比特估计值$\hat{u}{}_{1}=0,\hat{u}{}_{2}=0$。</p><script type="math/tex;mode=display">L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( L_{2}^{\left( 2 \right)}\left( y_{1}^{2},\hat{u}{}_{1}\oplus { { {\hat{u}}}_{2}} \right),L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right) \right)</script><p>其中，$L_{2}^{\left( 2 \right)}\left( y_{1}^{2},\hat{u}{}_{1}\oplus { { {\hat{u}}}_{2}} \right)$和$L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right)$递归地计算为</p><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{2}^{\left( 2 \right)}\left( y_{1}^{2},\hat{u}{}_{1}\oplus { { {\hat{u}}}_{2}} \right)=g\left( L_{1}^{\left( 1 \right)}\left( { {y}_{1}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{2}} \right),\hat{u}{}_{1}\oplus { { {\hat{u}}}_{2}} \right)=g\left( 1.5,2,0 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{0}}\times 1.5+2 \\ 
 \nonumber & =3.5 \\ 
\end{align}</script><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right)=g\left( L_{1}^{\left( 1 \right)}\left( { {y}_{3}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{4}} \right),{ { {\hat{u}}}_{2}} \right)=g\left( -1,0.5,0 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{0}}\times \left( -1 \right)+0.5 \\ 
 \nonumber & =-0.5 \\ 
\end{align}</script><p>从而，$L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( 3.5,-0.5 \right)=-0.47$。</p><p><strong>重新建立向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ -0.47 \right]</script><h4 id="b-001"><a href="#b-001" class="headerlink" title="b. 001"></a>b. 001</h4><p><br>同上，$L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( 3.5,-0.5 \right)=-0.47$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   -0.47 & -0.47  \\
\end{matrix} \right]</script><h4 id="c-010"><a href="#c-010" class="headerlink" title="c. 010"></a>c. 010</h4><p><br>比特估计值$\hat{u}{}_{1}=0,\hat{u}{}_{2}=1$。</p><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{2}^{\left( 2 \right)}\left( y_{1}^{2},\hat{u}{}_{1}\oplus { { {\hat{u}}}_{2}} \right)=g\left( L_{1}^{\left( 1 \right)}\left( { {y}_{1}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{2}} \right),\hat{u}{}_{1}\oplus { { {\hat{u}}}_{2}} \right)=g\left( 1.5,2,1 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{1}}\times 1.5+2 \\ 
 \nonumber & =0.5 \\ 
\end{align}</script><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right)=g\left( L_{1}^{\left( 1 \right)}\left( { {y}_{3}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{4}} \right),{ { {\hat{u}}}_{2}} \right)=g\left( -1,0.5,1 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{1}}\times \left( -1 \right)+0.5 \\ 
 \nonumber & =1.5 \\ 
\end{align}</script><p>从而，$L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( 0.5,1.5 \right)=0.31$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   \begin{matrix}
   -0.47 & -0.47  \\
\end{matrix} & 0.31  \\
\end{matrix} \right]</script><h4 id="d-011"><a href="#d-011" class="headerlink" title="d. 011"></a>d. 011</h4><p>同上，$L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( 0.5,1.5 \right)=0.31$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   \begin{matrix}
   \begin{matrix}
   -0.47 & -0.47  \\
\end{matrix} & 0.31  \\
\end{matrix} & 0.31  \\
\end{matrix} \right]</script><h3 id="计算候选路径的度量值-2"><a href="#计算候选路径的度量值-2" class="headerlink" title="计算候选路径的度量值"></a>计算候选路径的度量值</h3><p><br>分别计算$2L$条路径的度量值。</p><h4 id="a-000-1"><a href="#a-000-1" class="headerlink" title="a. 000"></a>a. 000</h4><p><br>$L_{4}^{\left( 3 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第1元素</font> ，即$L_{4}^{\left( 3 \right)}=-0.47$；比特估计值${ {\hat{u}}_{3}}=0$。</p><p>$\delta \left( L_{4}^{\left( 3 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -0.47 \right) \right)=1$。由于${ {u}_{3}}$为信息比特，且${ {\hat{u}}_{3}}\ne \delta \left( L_{4}^{\left( 3 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{3}=000 \right)=PM\left( \hat{u}_{1}^{2}=00 \right)+\left| L_{4}^{\left( 3 \right)} \right|=0.11+0.47=0.58</script><h4 id="b-001-1"><a href="#b-001-1" class="headerlink" title="b. 001"></a>b. 001</h4><p><br>$L_{4}^{\left( 3 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第2元素</font> ，即$L_{4}^{\left( 3 \right)}=-0.47$；比特估计值${ {\hat{u}}_{3}}=1$。</p><p>$\delta \left( L_{4}^{\left( 3 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -0.47 \right) \right)=1$。由于${ {u}_{3}}$为信息比特，且${ {\hat{u}}_{3}}=\delta \left( L_{4}^{\left( 3 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{3}=001 \right)=PM\left( \hat{u}_{1}^{2}=00 \right)\text{=}0.11</script><p>截止目前的扩展路径如图7所示。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170315/223032922.jpg" title="图 7 SCL译码算法在第3层的扩展"></p><h4 id="c-010-1"><a href="#c-010-1" class="headerlink" title="c. 010"></a>c. 010</h4><p><br>$L_{4}^{\left( 3 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第3元素</font> ，即$L_{4}^{\left( 3 \right)}=0.31$；比特估计值${ {\hat{u}}_{3}}=0$。</p><p>$\delta \left( L_{4}^{\left( 3 \right)} \right)=\frac{1}{2}\left( 1-sign\left( 0.31 \right) \right)=0$。由于${ {u}_{3}}$为信息比特，且${ {\hat{u}}_{3}}=\delta \left( L_{4}^{\left( 3 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{3}=010 \right)=PM\left( \hat{u}_{1}^{2}=01 \right)=0.94</script><h4 id="d-011-1"><a href="#d-011-1" class="headerlink" title="d. 011"></a>d. 011</h4><p><br>$L_{4}^{\left( 3 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第4元素</font> ，即$L_{4}^{\left( 3 \right)}=0.31$；比特估计值${ {\hat{u}}_{3}}=1$。</p><p>$\delta \left( L_{4}^{\left( 3 \right)} \right)=\frac{1}{2}\left( 1-sign\left( 0.31 \right) \right)=0$。由于${ {u}_{3}}$为信息比特，且${ {\hat{u}}_{3}}\ne \delta \left( L_{4}^{\left( 3 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{3}=011 \right)=PM\left( \hat{u}_{1}^{2}=01 \right)+L_{4}^{\left( 3 \right)}=0.94+0.31=1.25</script><p>截止目前的扩展路径如图8所示。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170427/134154868.jpg" title="图 8 SCL译码算法在第3层的扩展"></p><h3 id="剪枝-1"><a href="#剪枝-1" class="headerlink" title="剪枝"></a>剪枝</h3><p><br>将已经计算出的$2L$路径按照PM值从小到大排序，对这$2L$条路径进行剪枝操作：保留$L$条PM值最小的路径，并且删掉其余路径。如图9所示，被保留的路径为红色，被剪枝的路径均已变成灰色。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170427/134331096.jpg" title="图 9 剪枝"></p><h2 id="搜索第四层"><a href="#搜索第四层" class="headerlink" title="搜索第四层"></a>搜索第四层</h2><h3 id="计算第4个比特相关的LLR"><a href="#计算第4个比特相关的LLR" class="headerlink" title="计算第4个比特相关的LLR"></a>计算第4个比特相关的LLR</h3><p><br>分别计算$2L$条路径在第4层对应的LLR。</p><h4 id="a-0000"><a href="#a-0000" class="headerlink" title="a. 0000"></a>a. 0000</h4><p><br>比特估计值$\hat{u}{}_{1}=0,\hat{u}{}_{2}=0,\hat{u}{}_{3}=0$。</p><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{4}^{\left( 4 \right)}\left( y_{1}^{4},\hat{u}_{1}^{3} \right)=g\left( L_{2}^{\left( 2 \right)}\left( y_{1}^{2},{ { {\hat{u}}}_{1}}\oplus { { {\hat{u}}}_{2}} \right),L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right),{ { {\hat{u}}}_{3}} \right)=g\left( 3.5,-0.5,0 \right) \\ 
 \nonumber & ={ {\left( -1 \right)}^{0}}\times 3.5+\left( -0.5 \right) \\ 
 \nonumber & =3 \\ 
\end{align}</script><p><strong>重新建立向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ 3 \right]</script><h4 id="b-0001"><a href="#b-0001" class="headerlink" title="b. 0001"></a>b. 0001</h4><p><br>同上，$L_{4}^{\left( 4 \right)}\left( y_{1}^{4},\hat{u}_{1}^{3} \right)=3$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   3 & 3  \\
\end{matrix} \right]</script><h4 id="c-0010"><a href="#c-0010" class="headerlink" title="c. 0010"></a>c. 0010</h4><p><br>比特估计值$\hat{u}{}_{1}=0,\hat{u}{}_{2}=0,\hat{u}{}_{3}=1$。</p><script type="math/tex;mode=display">\begin{align}
 \nonumber & L_{4}^{\left( 4 \right)}\left( y_{1}^{4},u_{1}^{3} \right)=g\left( L_{2}^{\left( 2 \right)}\left( y_{1}^{2},{ {u}_{1}}\oplus { {u}_{2}} \right),L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ {u}_{2}} \right),{ {u}_{3}} \right)=g\left( 3.5,-0.5,1 \right) \\ 
\nonumber & ={ {\left( -1 \right)}^{1}}\times 3.5+\left( -0.5 \right) \\ 
\nonumber & =-4 \\ 
\end{align}</script><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   3 & 3 & -4  \\
\end{matrix} \right]</script><h4 id="d-0011"><a href="#d-0011" class="headerlink" title="d. 0011"></a>d. 0011</h4><p><br>同上，$L_{4}^{\left( 4 \right)}\left( y_{1}^{4},\hat{u}_{1}^{3} \right)=-4$。</p><p><strong>更新向量LLR</strong></p><script type="math/tex;mode=display">\mathbf{LLR}=\left[ \begin{matrix}
   \begin{matrix}
   3 & 3 & -4  \\
\end{matrix} & -4  \\
\end{matrix} \right]</script><h3 id="计算候选路径的度量值-3"><a href="#计算候选路径的度量值-3" class="headerlink" title="计算候选路径的度量值"></a>计算候选路径的度量值</h3><p><br>终于到最后一层了，继续计算$2L$个路径的度量值。</p><h4 id="a-0000-1"><a href="#a-0000-1" class="headerlink" title="a. 0000"></a>a. 0000</h4><p><br>$L_{4}^{\left( 4 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第1元素</font> ，即$L_{4}^{\left( 4 \right)}=3$；比特估计值${ {\hat{u}}_{4}}=0$。</p><p>$\delta \left( L_{4}^{\left( 4 \right)} \right)=\frac{1}{2}\left( 1-sign\left( 3 \right) \right)=0$。由于${ {u}_{4}}$为信息比特，且${ {\hat{u}}_{4}}=\delta \left( L_{4}^{\left( 4 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{4}=0000 \right)=PM\left( \hat{u}_{1}^{3}=000 \right)=0.58</script><h4 id="b-0001-1"><a href="#b-0001-1" class="headerlink" title="b. 0001"></a>b. 0001</h4><p><br>$L_{4}^{\left( 4 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第2元素</font> ，即$L_{4}^{\left( 4 \right)}=3$；比特估计值${ {\hat{u}}_{4}}=1$。</p><p>$\delta \left( L_{4}^{\left( 4 \right)} \right)=\frac{1}{2}\left( 1-sign\left( 3 \right) \right)=0$。由于${ {u}_{4}}$为信息比特，且${ {\hat{u}}_{4}}\ne \delta \left( L_{4}^{\left( 4 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{4}=0001 \right)=PM\left( \hat{u}_{1}^{3}=000 \right)+L_{4}^{\left( 4 \right)}=0.58+3=3.58</script><p>截止目前的扩展路径如图10所示。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170427/135823406.jpg" title="图 10 SCL译码算法在4层的扩展"></p><h4 id="c-0010-1"><a href="#c-0010-1" class="headerlink" title="c. 0010"></a>c. 0010</h4><p><br>$L_{4}^{\left( 4 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第3元素</font> ，即$L_{4}^{\left( 4 \right)}=-4$；比特估计值${ {\hat{u}}_{4}}=0$。</p><p>$\delta \left( L_{4}^{\left( 4 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -4 \right) \right)=1$。由于${ {u}_{4}}$为信息比特，且${ {\hat{u}}_{4}}\ne \delta \left( L_{4}^{\left( 4 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{4}=0010 \right)=PM\left( \hat{u}_{1}^{3}=001 \right)+\left| L_{4}^{\left( 4 \right)} \right|=0.11+4=4.\text{11}</script><h4 id="d-0011-1"><a href="#d-0011-1" class="headerlink" title="d. 0011"></a>d. 0011</h4><p><br>$L_{4}^{\left( 4 \right)}$取向量$\mathbf{LLR}$的<font color="#FF0000"> 第4元素</font> ，即$L_{4}^{\left( 4 \right)}=-4$；比特估计值${ {\hat{u}}_{4}}=1$。</p><p>$\delta \left( L_{4}^{\left( 4 \right)} \right)=\frac{1}{2}\left( 1-sign\left( -4 \right) \right)=1$。由于${ {u}_{4}}$为信息比特，且${ {\hat{u}}_{4}}=\delta \left( L_{4}^{\left( 4 \right)} \right)$，所以有</p><script type="math/tex;mode=display">PM\left( \hat{u}_{1}^{4}=0011 \right)=PM\left( \hat{u}_{1}^{3}=001 \right)=0.11</script><p>截止目前的扩展路径如图11所示。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170427/140245285.jpg" title="图 11 SCL译码算法在4层的扩展"></p><h3 id="剪枝-2"><a href="#剪枝-2" class="headerlink" title="剪枝"></a>剪枝</h3><p><br>到了最后一层，选取PM最小的路径作为唯一路径，即为译码输出结果：$\hat{u}_{1}^{4}=\left( \begin{matrix}<br>0 &amp; 0 &amp; 1 &amp; 1 \\<br>\end{matrix} \right)$。如图12所示，只保留这一条路径，删除其余路径。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170427/140423071.jpg" title="图 12 SCL译码算法输出结果"></p><p>注意，此时的$\hat{u}_{1}^{4}=\left( \begin{matrix}<br>0 &amp; 0 &amp; 1 &amp; 1 \\<br>\end{matrix} \right)$并不是按正常顺序排列的译码结果。别忘了极化码编码时是经过比特反转的，$\left( \begin{matrix}<br>0 &amp; 0 &amp; 1 &amp; 1 \\<br>\end{matrix} \right)$对应的比特位置是$\left( \begin{matrix}<br>1 &amp; 3 &amp; 2 &amp; 4 \\<br>\end{matrix} \right)$。所以再比特反转一次，得到最终的译码比特$\left( \begin{matrix}<br>0 &amp; 1 &amp; 0 &amp; 1 \\<br>\end{matrix} \right)$，其中第2、4位发生了译码错误。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><br>SC译码算法是深度优先的，要的是从根节点快速到达叶子节点。而SCL译码算法是广度优先的，先扩展，再剪枝，最终到达叶子节点。SCL译码算法的PM机制就像“马太效应”，越是错误的路径越要施加惩罚，越是正确的路径越可以直接继承父节点以便保证自己具有最小的PM。对于信息比特且${ {\hat{u}}_{i}}\left[ l \right]$与$\delta \left( L_{N}^{\left( i \right)}\left[ l \right] \right)$相等的情况，该比特直接继承父节点的PM；对于信息比特且${ {\hat{u}}_{i}}\left[ l \right]$与$\delta \left( L_{N}^{\left( i \right)}\left[ l \right] \right)$不相等的情况则次之，施加一个惩罚因子，该惩罚因子的大小就是LLR的模值；对于冻结比特而且还取值错误的情况是最坏的，施加的惩罚因子是无穷大。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><br>[1] Tal I, Vardy A. List Decoding of Polar Codes[J]. Information Theory IEEE Transactions on, 2012, 61(5):2213-2226.<br>[2] Balatsoukas-Stimming A, Parizi M B, Burg A. LLR-Based Successive Cancellation List Decoding of Polar Codes[J]. IEEE Transactions on Signal Processing, 2015, 63(19):5165-5179.<br>[3] 陈凯. 极化编码理论与实用方案研究[D]. 北京邮电大学, 2014.</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Polar-Code/" rel="tag"><i class="fa fa-tag"></i> Polar Code</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/03/13/polar-code-6-sc-decoder/" rel="next" title="Polar Code（6）SC译码算法"><i class="fa fa-chevron-left"></i> Polar Code（6）SC译码算法</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/03/17/polar-code-8-gaussian-approximation/" rel="prev" title="Polar Code（8）高斯近似">Polar Code（8）高斯近似 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><script>with(document)(0)[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)]</script></div></div></div><div class="comments" id="comments"><div id="SOHUCS" sid=""></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Marshall"><p class="site-author-name" itemprop="name">Marshall</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SC译码算法的码树表示"><span class="nav-number">2.</span> <span class="nav-text">SC译码算法的码树表示</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SCL译码算法"><span class="nav-number">3.</span> <span class="nav-text">SCL译码算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#思考"><span class="nav-number">3.1.</span> <span class="nav-text">思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径度量值"><span class="nav-number">3.2.</span> <span class="nav-text">路径度量值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SCL译码示例"><span class="nav-number">4.</span> <span class="nav-text">SCL译码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索第一层"><span class="nav-number">4.1.</span> <span class="nav-text">搜索第一层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算第1个比特相关的LLR"><span class="nav-number">4.1.1.</span> <span class="nav-text">计算第1个比特相关的LLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算候选路径的度量值"><span class="nav-number">4.1.2.</span> <span class="nav-text">计算候选路径的度量值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-0"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">a. 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-1"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">b. 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径扩展"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">路径扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索第二层"><span class="nav-number">4.2.</span> <span class="nav-text">搜索第二层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算第2个比特相关的LLR"><span class="nav-number">4.2.1.</span> <span class="nav-text">计算第2个比特相关的LLR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-00"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">a. 00</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-01"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">b. 01</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-10"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">c. 10</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-11"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">d. 11</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算候选路径的度量值-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">计算候选路径的度量值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-00-1"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">a. 00</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-01-1"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">b. 01</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-10-1"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">c. 10</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-11-1"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">d. 11</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剪枝"><span class="nav-number">4.2.3.</span> <span class="nav-text">剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索第三层"><span class="nav-number">4.3.</span> <span class="nav-text">搜索第三层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算第3个比特相关的LLR"><span class="nav-number">4.3.1.</span> <span class="nav-text">计算第3个比特相关的LLR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-000"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">a. 000</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-001"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">b. 001</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-010"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">c. 010</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-011"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">d. 011</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算候选路径的度量值-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">计算候选路径的度量值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-000-1"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">a. 000</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-001-1"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">b. 001</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-010-1"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">c. 010</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-011-1"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">d. 011</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剪枝-1"><span class="nav-number">4.3.3.</span> <span class="nav-text">剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索第四层"><span class="nav-number">4.4.</span> <span class="nav-text">搜索第四层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算第4个比特相关的LLR"><span class="nav-number">4.4.1.</span> <span class="nav-text">计算第4个比特相关的LLR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-0000"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">a. 0000</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-0001"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">b. 0001</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-0010"><span class="nav-number">4.4.1.3.</span> <span class="nav-text">c. 0010</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-0011"><span class="nav-number">4.4.1.4.</span> <span class="nav-text">d. 0011</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算候选路径的度量值-3"><span class="nav-number">4.4.2.</span> <span class="nav-text">计算候选路径的度量值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-0000-1"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">a. 0000</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-0001-1"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">b. 0001</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-0010-1"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">c. 0010</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-0011-1"><span class="nav-number">4.4.2.4.</span> <span class="nav-text">d. 0011</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剪枝-2"><span class="nav-number">4.4.3.</span> <span class="nav-text">剪枝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">6.</span> <span class="nav-text">参考文献</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-star"></i> </span><span class="author" itemprop="copyrightHolder">Marshall</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/three-waves.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><script type="text/javascript">!function(){var t="cytaUfAfH",e="prod_d168db90253ab2bc78368034d167c214",n=window.innerWidth||document.documentElement.clientWidth;if(n<960)window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+t+"&conf="+e+'"><\/script>');else{var a=function(t,e){var n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,a=document.createElement("script");a.setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src",t),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)};a("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:t,conf:e})})}}()</script><script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html><!-- rebuild by neat -->