<!-- build time:Thu Jul 06 2017 22:37:23 GMT+0800 (中国标准时间) --><!doctype html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PingFang SC:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Polar Code,"><link rel="alternate" href="/atom.xml" title="Marshall" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="前言Arikan在文献[1]中给出了Polar Code译码算法，即串行抵消（Successive Cancellation，SL）译码算法。由Polar Code编码原理可知，极化码的构造就是一个极化信道的选择问题，而极化信道的选择实际上是按照最优化SC译码性能为标准的。根据极化信道转移概率函数式，各个极化信道并不是相互独立的，而是具有确定的依赖关系的：信道序号大的极化信道依赖于所有比其序号小的"><meta property="og:type" content="article"><meta property="og:title" content="Polar Code（6）SC译码算法"><meta property="og:url" content="https://marshallcomm.github.io/2017/03/13/polar-code-6-sc-decoder/index.html"><meta property="og:site_name" content="Marshall"><meta property="og:description" content="前言Arikan在文献[1]中给出了Polar Code译码算法，即串行抵消（Successive Cancellation，SL）译码算法。由Polar Code编码原理可知，极化码的构造就是一个极化信道的选择问题，而极化信道的选择实际上是按照最优化SC译码性能为标准的。根据极化信道转移概率函数式，各个极化信道并不是相互独立的，而是具有确定的依赖关系的：信道序号大的极化信道依赖于所有比其序号小的"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170314/134726685.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170314/134751778.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170314/134810378.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170314/134828384.jpg"><meta property="og:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170314/134848915.jpg"><meta property="og:updated_time" content="2017-03-31T11:13:44.724Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Polar Code（6）SC译码算法"><meta name="twitter:description" content="前言Arikan在文献[1]中给出了Polar Code译码算法，即串行抵消（Successive Cancellation，SL）译码算法。由Polar Code编码原理可知，极化码的构造就是一个极化信道的选择问题，而极化信道的选择实际上是按照最优化SC译码性能为标准的。根据极化信道转移概率函数式，各个极化信道并不是相互独立的，而是具有确定的依赖关系的：信道序号大的极化信道依赖于所有比其序号小的"><meta name="twitter:image" content="http://olyzl8414.bkt.clouddn.com/blog/20170314/134726685.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://marshallcomm.github.io/2017/03/13/polar-code-6-sc-decoder/"><title>Polar Code（6）SC译码算法 | Marshall</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Marshall</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Comm. Tech. Blog</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://marshallcomm.github.io/2017/03/13/polar-code-6-sc-decoder/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Marshall"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Marshall"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Polar Code（6）SC译码算法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T22:23:42+08:00">2017-03-13 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/研究笔记/" itemprop="url" rel="index"><span itemprop="name">研究笔记</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a class="cloud-tie-join-count" href="/2017/03/13/polar-code-6-sc-decoder/#comments" itemprop="discussionUrl"><span class="post-comments-count join-count" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><br>Arikan在文献[1]中给出了Polar Code译码算法，即串行抵消（Successive Cancellation，SL）译码算法。由Polar Code编码原理可知，极化码的构造就是一个极化信道的选择问题，而极化信道的选择实际上是按照最优化SC译码性能为标准的。根据极化信道转移概率函数式，各个极化信道并不是相互独立的，而是具有确定的依赖关系的：信道序号大的极化信道依赖于所有比其序号小的极化信道。基于极化信道之间的这一依赖关系，SC译码算法对各个比特进行译码判决时，需要假设之前步骤的译码得到的结果都是正确的。并且正是在这种译码算法下，极化码被证明了是信道容量可达的。因此对极化码而言，最合适的译码算法应当是基于SC译码的，只有这类译码算法才能充分利用极化码的结构，并且同时保证在码长足够长时容量可达。</p><a id="more"></a><h1 id="SC译码算法"><a href="#SC译码算法" class="headerlink" title="SC译码算法"></a>SC译码算法</h1><p><br>在进行译码时，从式（1）的转移概率可以看出，序号$i$极化信道$W_{N}^{\left( i \right)}$的输出包括信道接收信号$y_{1}^{N}$以及前$i-1$个极化信道的输入$u_{1}^{i-1}$两个部分。</p><script type="math/tex;mode=display">\begin{align}
W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|{ {u}_{i}} \right)\triangleq \sum\limits_{u_{i+1}^{N}\in { {X}^{N-i}}}{\frac{1}{ { {2}^{N-1}}}{ {W}_{N}}\left( y_{1}^{N}|u_{1}^{N} \right)}
\end{align}</script><p>因此，对于$i\in \left\{ 1,2,…,N \right\}$，比特${ {u}_{i}}$的估计值${ {\hat{u}}_{i}}$可以根据接收信号$y_{1}^{N}$和部分估计序列$u_{1}^{i-1}$通过计算当${ {\hat{u}}_{i}}=0$或${ {\hat{u}}_{i}}=1$时$W_{N}^{\left( i \right)}$的转移概率进行逐个地判断。这种译码算法称为串行抵消（SC）译码算法：对信道序号$i$从1到N取值，各个比特的估计值根据以下公式得到：</p><script type="math/tex;mode=display">\begin{align}
{ {\hat{u}}_{i}}=\left\{ \begin{matrix}
   { {h}_{i}}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right),\ \ if\ i\in A  \\
   { {u}_{i}},\ \ if\ i\in { {A}^{c}}  \\
\end{matrix} \right.
\end{align}</script><p>其中，当$i\in { {A}^{c}}$时，表明该比特为冻结比特，即收发端事先约定的比特，因此直接判决为${ {\hat{u}}_{i}}={ {u}_{i}}$；当$i\in A$时，表明该比特为承载信息的信息比特，判决函数为</p><script type="math/tex;mode=display">\begin{align}
{ {h}_{i}}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)=\left\{ \begin{matrix}
   0,\ \ if\ L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)\ge 0  \\
   1,\ \ if\ L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)<0\   \\
\end{matrix} \right.
\end{align}</script><p>定义对数似然比（Log-Likelihood Ratio，LLR）为</p><script type="math/tex;mode=display">\begin{align}
L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)\triangleq \ln \left( \frac{W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}|0 \right)}{W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}|1 \right)} \right)
\end{align}</script><p>LLR的计算可以通过递归完成。现定义函数$f$和$g$如下：</p><script type="math/tex;mode=display">\begin{align}
f\left( a,b \right)=\ln \left( \frac{1+{ {e}^{a+b}}}{ { {e}^{a}}+{ {e}^{b}}} \right)
\end{align}</script><script type="math/tex;mode=display">\begin{align}
g\left( a,b,{ {u}_{s}} \right)={ {\left( -1 \right)}^{ { {u}_{s}}}}a+b
\end{align}</script><p>其中，$a,b\in R,{ {u}_{s}}\in \left\{ 0,1 \right\}$。LLR的递归运算借助函数$f$和$g$表示如下：</p><script type="math/tex;mode=display">\begin{align}
L_{N}^{\left( 2i-1 \right)}\left( y_{1}^{N},\hat{u}_{1}^{2i-2} \right)=f\left( L_{N/2}^{\left( i \right)}\left( y_{1}^{ {N}/{2}\;},\hat{u}_{1,o}^{2i-2}\oplus \hat{u}_{1,e}^{2i-2} \right),L_{N/2}^{\left( i \right)}\left( y_{ {N}/{2}\;+1}^{N},\hat{u}_{1,e}^{2i-2} \right) \right)
\end{align}</script><script type="math/tex;mode=display">\begin{align}
L_{N}^{\left( 2i \right)}\left( y_{1}^{N},\hat{u}_{1}^{2i-1} \right)=g\left( L_{N/2}^{\left( i \right)}\left( y_{1}^{ {N}/{2}\;},\hat{u}_{1,o}^{2i-2}\oplus \hat{u}_{1,e}^{2i-2} \right),L_{N/2}^{\left( i \right)}\left( y_{ {N}/{2}\;+1}^{N},\hat{u}_{1,e}^{2i-2} \right),{ { {\hat{u}}}_{2i-1}} \right)
\end{align}</script><p>递归的终止条件为当$N=1$时，即到达了信道$W$端，此时$L_{1}^{\left( 1 \right)}\left( { {y}_{j}} \right)=\ln \frac{W\left( { {y}_{j}}|0 \right)}{W\left( { {y}_{j}}|1 \right)}$，可以根据信道$W$的转移概率和接收符号值直接计算出结果。</p><p>定义事件“SC译码算法得到的译码码块错误”为$E=\bigcup\nolimits_{i=1}^{N}{ { {B}_{i}}}$，其中事件</p><script type="math/tex;mode=display">\begin{align}
{ {B}_{i}}=\left\{ u_{1}^{N},y_{1}^{N}:u_{1}^{i-1}=\hat{u}_{1}^{i-1},W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|{ {u}_{i}} \right)<W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|{ {u}_{i}}\oplus 1 \right) \right\}
\end{align}</script><p>表示“SC译码过程中第一个错误判决发生在第$i$个比特”。由于${ {B}_{i}}\subset { {A}_{i}}$（事件${ {A}_{i}}$的定义参看<a href="https://marshallcomm.github.io/2017/03/07/polar-code-4-encoding-chan-rel-est/">《Polar Code（4）编码之极化信道可靠性估计》</a>前言），因此有$E\subset \sum\limits_{i\in A}{P\left( { {A}_{i}} \right)}$，于是</p><script type="math/tex;mode=display">\begin{align}
P\left( E \right)\le \sum\nolimits_{i\in A}{P\left( { {A}_{i}} \right)}
\end{align}</script><p>其中$P\left( { {A}_{i}} \right)$的值可根据前文所述的计算巴氏参数、密度进化或高斯近似方法得到。因此，通过式（6）可以得到极化码在SC译码下的误块率（BLER）性能上界。</p><h1 id="SC译码示例"><a href="#SC译码示例" class="headerlink" title="SC译码示例"></a>SC译码示例</h1><p><br>现在以码长$N=4$，消息比特数为$K=3$的极化码为例，对SC译码进行说明。在图1中，${ {u}_{1}}$为冻结比特并设定为零值，而消息比特也假设为全零，最右端的$L_{1}^{\left( 1 \right)}\left( { {y}_{j}} \right)$表示接收自信道的对数似然比。其他节点表示中间估计结果以及中间译码结果。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170314/134726685.jpg" title="图 1 极化码的SC译码，初始状态"></p><p>需要说明的是，编码过程中计算转移概率是从图的左边逐级向右边递归。而在译码过程中，计算信道的LLR要从右边逐级向左递归。</p><p>SC译码算法将首先计算${ {u}_{1}}$的对数似然比$L_{4}^{\left( 1 \right)}\left( y_{1}^{4} \right)$。根据式（5）和式（7），如图2所示，首先计算出$L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right)$和$L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right)$的值，其中</p><script type="math/tex;mode=display">\begin{align}
L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right)=f\left( L_{1}^{\left( 1 \right)}\left( { {y}_{1}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{2}} \right) \right)\text{=}\ln \left( \frac{1+{ {e}^{1.5+2}}}{ { {e}^{1.5}}+{ {e}^{2}}} \right)=1.06
\end{align}</script><script type="math/tex;mode=display">\begin{align}
L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right)=f\left( L_{1}^{\left( 1 \right)}\left( { {y}_{3}} \right),L_{1}^{\left( 1 \right)}\left( { {y}_{4}} \right) \right)\text{=}\ln \left( \frac{1+{ {e}^{-1+0.5}}}{ { {e}^{-1}}+{ {e}^{0.5}}} \right)=-0.23
\end{align}</script><p>接着计算出$L_{4}^{\left( 1 \right)}\left( y_{1}^{4} \right)$：</p><script type="math/tex;mode=display">\begin{align}
L_{4}^{\left( 1 \right)}\left( y_{1}^{4} \right)=f\left( L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right),L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right) \right)=\ln \left( \frac{1+{ {e}^{1.06-0.23}}}{ { {e}^{1.06}}+{ {e}^{-0.23}}} \right)=-0.11
\end{align}</script><p>虽然$L_{4}^{\left( 1 \right)}\left( y_{1}^{4} \right)&lt;0$，但由于${ {u}_{1}}$是冻结比特，我们依然将${ {u}_{1}}$判决为${ {\hat{u}}_{1}}=0$。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170314/134751778.jpg" title="图 2 极化码的SC译码，对${ {u}_{1}}$译码"></p><p>接着对${ {u}_{2}}$进行译码，如图3所示，根据式（6）和式（8）可得</p><script type="math/tex;mode=display">\begin{align}
L_{4}^{\left( 2 \right)}\left( y_{1}^{4},{ { {\hat{u}}}_{1}} \right)={ {\left( -1 \right)}^{ { { {\hat{u}}}_{1}}}}L_{2}^{\left( 1 \right)}\left( y_{1}^{2} \right)+L_{2}^{\left( 1 \right)}\left( y_{3}^{4} \right)={ {\left( -1 \right)}^{0}}\times 1.06+\left( -0.23 \right)=0.83
\end{align}</script><p>由于${ {u}_{2}}$是消息比特且$L_{4}^{\left( 2 \right)}\left( y_{1}^{4},{ { {\hat{u}}}_{1}} \right)&gt;0$，因此判决为${ {\hat{u}}_{2}}=0$，此处为正确译码。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170314/134810378.jpg" title="图 3 极化码的SC译码，对${ {u}_{2}}$译码"></p><p>接着对${ {u}_{3}}$进行译码，如图4所示，根据式（5）和式（7）可得</p><script type="math/tex;mode=display">\begin{align}
L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( L_{2}^{\left( 2 \right)}\left( y_{1}^{2},{ { {\hat{u}}}_{1}}\oplus { { {\hat{u}}}_{2}} \right),L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right) \right)
\end{align}</script><p>这里需要先求$L_{2}^{\left( 2 \right)}\left( y_{1}^{2},{ { {\hat{u}}}_{1}}\oplus { { {\hat{u}}}_{2}} \right)$，根据式（6）和式（8）可得</p><script type="math/tex;mode=display">\begin{align}
L_{2}^{\left( 2 \right)}\left( y_{1}^{2},{ { {\hat{u}}}_{1}}\oplus { { {\hat{u}}}_{2}} \right)={ {\left( -1 \right)}^{ { { {\hat{u}}}_{1}}\oplus { { {\hat{u}}}_{2}}}}L_{1}^{\left( 1 \right)}\left( { {y}_{1}} \right)+L_{1}^{\left( 1 \right)}\left( { {y}_{2}} \right)={ {\left( -1 \right)}^{0}}\times 1.5+2=3.5
\end{align}</script><p>再求$L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right)$，根据根据式（6）和式（8）可得</p><script type="math/tex;mode=display">\begin{align}
L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right)\text{=}{ {\left( -1 \right)}^{ { { {\hat{u}}}_{2}}}}L_{1}^{\left( 1 \right)}\left( { {y}_{3}} \right)+L_{1}^{\left( 1 \right)}\left( { {y}_{4}} \right)={ {\left( -1 \right)}^{0}}\times \left( -1 \right)+0.5=-0.5
\end{align}</script><p>把式（16）和式（17）带入到式（15）得到</p><script type="math/tex;mode=display">\begin{align}
L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)=f\left( 3.5,-0.5 \right)\text{=}\ln \left( \frac{1+{ {e}^{3.5-0.5}}}{ { {e}^{3.5}}+{ {e}^{-0.5}}} \right)=-0.47
\end{align}</script><p>由于$L_{4}^{\left( 3 \right)}\left( y_{1}^{4},\hat{u}_{1}^{2} \right)&lt;0$，因此判决${ {\hat{u}}_{3}}=1$，此处发生译码错误。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170314/134828384.jpg" title="图 4 极化码的SC译码，对${ {u}_{3}}$译码"></p><p>最后对${ {u}_{4}}$进行译码，如图5所示，根据式（6）和式（8）可得</p><script type="math/tex;mode=display">\begin{align}
  \nonumber & L_{4}^{\left( 4 \right)}\left( y_{1}^{4},\hat{u}_{1}^{3} \right)={ {\left( -1 \right)}^{ { { {\hat{u}}}_{3}}}}L_{2}^{\left( 2 \right)}\left( y_{1}^{2},{ { {\hat{u}}}_{1}}\oplus { { {\hat{u}}}_{2}} \right)+L_{2}^{\left( 2 \right)}\left( y_{3}^{4},{ { {\hat{u}}}_{2}} \right) \\ 
\nonumber & ={ {\left( -1 \right)}^{1}}\times 3.5+\left( -0.5 \right) \\ 
 & =-4 \\ 
\end{align}</script><p>由于$L_{4}^{\left( 4 \right)}\left( y_{1}^{4},\hat{u}_{1}^{3} \right)&lt;0$，因此判决${ {\hat{u}}_{4}}=1$，此处发生译码错误。</p><p><img src="http://olyzl8414.bkt.clouddn.com/blog/20170314/134848915.jpg" title="图 5 极化码的SC译码，对${ {u}_{4}}$译码"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><br>SC译码算法以LLR为判决准则，对每一个比特进行硬判决，按比特序号从小到大的顺序依次判决译码。当码长趋近于无穷时，由于各个分裂信道接近完全极化（其信道容量或者为0或者为1），毎个消息比特都会获得正确的译码结果，可以在理论上使得极化码达到信道的对称容量$I\left( W \right)$。而且SC译码器的复杂度仅为$O\left( N\log N \right)$和码长呈近似线性的关系。然而，在有限码长下，由于信道极化并不完全，依然会存在一些消息比特无法被正确译码。当前面$i-1$个消息比特的译码中发生错误之后，由于SC译码器在对后面的消息比特译码时需要用到之前的消息比特的估计值，这就会导致较为严重的错误传递。因此，对于有限码长的极化码，采用SC译码器往往不能达到理想的性能。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><br>[1] Arikan E. Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels[J]. IEEE Transactions on Information Theory, 2008, 55(7):3051-3073.<br>[2] 张亮. 极化码的译码算法研究及其应用[D].浙江大学,2016.</p></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Polar-Code/" rel="tag"># Polar Code</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/03/12/polar-code-5-encoding-chan-trans-prob/" rel="next" title="Polar Code（5）编码之信道转移概率"><i class="fa fa-chevron-left"></i> Polar Code（5）编码之信道转移概率</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/03/15/polar-code-7-scl-decoder/" rel="prev" title="Polar Code（7）SCL译码算法">Polar Code（7）SCL译码算法 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="bdsharebuttonbox"><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a> <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a> <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a> <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a> <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a> <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a> <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a> <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a> <a href="#" class="bds_more" data-cmd="more"></a> <a class="bds_count" data-cmd="count"></a></div><script>window._bd_share_config={common:{bdText:"",bdMini:"2",bdMiniList:!1,bdPic:""},share:{bdSize:"16",bdStyle:"0"},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"}}</script><script>with(document)(0)[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)]</script></div></div></div><div class="comments" id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Marshall"><p class="site-author-name" itemprop="name">Marshall</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="http://weibo.com/mashuo" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo </a></span><span class="links-of-author-item"><a href="https://twitter.com/CommMarshall" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter </a></span><span class="links-of-author-item"><a href="mailto:marshallcomm@163.com" target="_blank" title="Email"><i class="fa fa-fw fa-envelope"></i> Email</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SC译码算法"><span class="nav-number">2.</span> <span class="nav-text">SC译码算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SC译码示例"><span class="nav-number">3.</span> <span class="nav-text">SC译码示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">5.</span> <span class="nav-text">参考文献</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Marshall</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span> <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script>var cloudTieConfig={url:document.location.href,sourceId:"",productKey:"08b056ac5efc4b2a889a7baf95500973",target:"cloud-tie-wrapper"}</script><script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="local-search-pop-overlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=s&&a.forEach(function(e,t){i=s.indexOf(e),l=n.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html><!-- rebuild by neat -->