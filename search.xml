<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[polar-code-4-encoding-channel-error-prob]]></title>
      <url>%2F2017%2F03%2F07%2Fpolar-code-4-encoding-channel-error-prob%2F</url>
      <content type="text"><![CDATA[前言由Arikan发明的Polar Code经典编码算法已在《Polar Code（2）编码原理》中阐明，《Polar Code（3）编码实例》则是对前文的举例。在编码实例中，有两个前提假设：假设一个二进制删除信道（BEC）；假设采用计算巴氏参数来评估各分裂子信道的可靠性。Arikan在讨论信道极化时，针对的是二进制离散无记忆信道（B-DMC），然而在构造极化码时需要计算的巴氏参数$Z\left( W \right)$的适用范围是二进制删除信道。BEC是B-DMC的子集。因此在Polar Code编码时只能回落的BEC来进行构造。当信道不是BEC信道时，比如二元对称信道（BSC）或二进制高斯白噪声信道（BAWGNC），则超出了$Z\left( W \right)$的适用范围，各个分裂信道的$Z\left( W{}_{N}^{\left( i \right)} \right)$无法精确得到。为了更精确地估计信道极化中各分裂信道的可靠性，Mori等人提出了密度进化（Density Evolution，DE）的构造方法。该方法适用于所有类型的B-DMC。密度进化（DE）类似LDPC码等信道编码，信道极化也可以用Tanner图的结构来表示。下图给出了一个$N=8$的例子，图中圆圈表示变量节点，每个变量节点代码一个比特，同时也存储了该比特取值为0或1时的概率；而方框则表示校验节点，表示与之相连的各变量节点比特值的检验和为零。由于变量节点的比特值仅可能有0或1两种取值，因此，存储与变量节点的消息往往用对数似然比（LLR）值来表示。\begin{equation} L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)=\ln \left( \frac{W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}|0 \right)}{W_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1}|1 \right)} \right) \end{equation}根据《Polar Code（2）编码原理》中递归式$W_{N}^{\left( 2i-1 \right)}\left( y_{1}^{N},u_{1}^{2i-2}|{u_{2i-1}} \right)$与式$W_{N}^{\left( 2i \right)}\left( y_{1}^{N},u_{1}^{2i-1}|{u_{2i}} \right)$，Tanner图中各个变量节点的LLR值可以递归地计算得到\begin{align} & L_{N}^{\left( 2i-1 \right)}\left( y_{1}^{N},\hat{u}_{1}^{2i-2} \right)=2{\tanh ^{-1}}\left( \tanh \left( \frac{L_{N/{2}\;}^{\left( i \right)}\left( y_{1}^{N/{2}\;},\hat{u}_{1,o}^{2i-2}\oplus \hat{u}_{1,e}^{2i-2} \right)}{2} \right) \right) \\ & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \nonumber \cdot \tanh \left( \frac{L_{N/{2}\;}^{\left( i \right)}\left( y_{N/{2}\;+1}^{N},\hat{u}_{1,e}^{2i-2} \right)}{2} \right) \\ \end{align}\begin{align} & L_{N}^{\left( 2i \right)}\left( y_{1}^{N},\hat{u}_{1}^{2i-1} \right)=L_{ {N}/{2}\;}^{\left( i \right)}\left( y_{ {N}/{2}\;+1}^{N},\hat{u}_{1,e}^{2i-2} \right)+{ {\left( -1 \right)}^{ { { {\hat{u}}}_{2i-1}}}} \\ & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \nonumber \cdot L_{ {N}/{2}\;}^{\left( i \right)}\left( y_{1}^{ {N}/{2}\;},\hat{u}_{1,o}^{2i-2}\oplus \hat{u}_{1,e}^{2i-2} \right) \\ \end{align}若最终得到的$L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)\ge 0$，则判决为${\hat{u}_{i}}=0$；否则，判决${\hat{u}_{i}}=1$。将某一个变量节点的LLR值视为一个随机变量，用$\mathbf{a}\left( z \right)$表示该随机变量的概率密度函数（PDF）。由于信道满足对称性，可以假设发送的比特为全零。从而该变量节点的比特判决值错误的概率为\begin{equation} {P_{e}}=\int_{-\infty }^{0}{\mathbf{a}\left( z \right)}dz \end{equation}在对第$i$个信道进行可靠性计算时，如上图中加粗线条所示，以比特${u_{i}}$对应的变量节点为根节点，逐层扩展，直至最右侧一列变量节点，构成译码树。用${\mathbf{a}_{w}}$表示信道输入到最右侧一列变量节点的LLR值的PDF；用$\mathbf{a}_{N}^{\left( i \right)}$表示$L_{N}^{\left( i \right)}\left( y_{1}^{N},\hat{u}_{1}^{i-1} \right)$值的PDF。根据密度进化理论以及式（2）和式（3），假设发送序列为全零比特序列，在$u_{1}^{i-1}$值已知的条件下，序号为$i$的极化信道LLR值可以递归第计算如下\begin{equation} \mathbf{a}_{N}^{\left( 2i-1 \right)}=\mathbf{a}_{N/{2}\;}^{\left( i \right)}\odot \mathbf{a}_{N/{2}\;}^{\left( i \right)} \end{equation}\begin{equation} \mathbf{a}_{N}^{\left( i \right)}=\mathbf{a}_{N/{2}\;}^{\left( i \right)}*\mathbf{a}_{N/{2}\;}^{\left( i \right)} \end{equation}\begin{equation} \mathbf{a}_{1}^{\left( 1 \right)}\text{=}{\mathbf{a}_{w}} \end{equation}其中，运算$\odot $与$*$分布表示校验节点与变量节点上的卷积操作。通过概率密度函数$\mathbf{a}_{N}^{\left( i \right)}$与式（30）可以得到各个极化信道$W_{N}^{\left( i \right)}$的可靠性度量$P\left( {A_{i}} \right)$。高斯近似（GA）通过密度进化对极化信道$W_{N}^{\left( i \right)}$的可靠性度量$P\left( {A_{i}} \right)$进行计算，可以适用于任意类型的B-DMC信道。然而，在实际算法实现时，需要维护一个高维的向量以存储（量化后的）概率密度函数$\mathbf{a}_{N}^{\left( i \right)}$。为保证计算结果精确，该向量的维度常取到${10^{6}}$，对如此高维的向量进行式（5）和式（6）的卷积操作，计算复杂度非常高。在大多数研究场景下，信道编码的传输信道模型均为BAWGNC信道。在BAWGNC信道下，可以将密度进化中的LLR值的概率密度函数用一族方差为均值2倍的高斯分布来近似，从而简化成了对一维的均值的计算，大大降低计算量，这种对DE的简化计算即为高斯近似（Gaussian Approximation，GA）。对噪声方差为${\sigma ^{2}}$的BAWGNC信道，若从信道获取的接收信号为$y$。\begin{equation} y=\left( 2x-1 \right)+z \end{equation}其中发送比特$x\in \left\{ 0,1 \right\}$，$z\sim N\left( 0,{\sigma ^{2}} \right)$。假设发送比特为全零序列，则对应的LLR值为\begin{equation} LLR\left( y \right)=\ln \frac{p\left( y|x=0 \right)}{p\left( y|x=1 \right)}=\frac{2}{\sigma ^{2}}y \end{equation}其中$y\sim N\left( 0,{\sigma ^{2}} \right)$。因此式（9）中所得的LLR值符合均值为$2/{\sigma ^{2}}\;$、方差为$4/{\sigma ^{2}}\;$的高斯分布。根据已有的高斯近似理论，若输入的消息$\mathbf{a}_{N/{2}\;}^{\left( i \right)}$服从独立的高斯分布，对如式（6）所示的变量节点上的操作，则其输出$\mathbf{a}_{N}^{\left( i \right)}$也服从高斯分布；对如式（5）所示的变量节点上的操作，其输出$\mathbf{a}_{N}^{\left( 2i-1 \right)}$也非常接近高斯分布。由于高斯分布可以有其均值和方差完全决定，因此在概率密度函数的计算过程中值需要考虑均值和方差，但必需满足密度进化的对称条件。如果用$f\left( z \right)$表示LLR的概率密度，则对称条件表示为$f\left( z \right)\text{=}f\left( -z \right){e^{z}}$。对于均值为$m$、方差为${\sigma ^{2}}$的高斯分布，该对称条件可以简化为${\sigma ^{2}}=2m$。因此，在高斯近似中，仅需要考虑一维的变量，即均值$m$。设$\mathbf{a}_{N}^{\left( i \right)}$可以用$N\left( m_{N}^{\left( i \right)},2m_{N}^{\left( i \right)} \right)$表示，则式（5）、式（6）和式（7）中所示的LLR计算过程可以用高斯近似成为\begin{equation} m_{N}^{\left( 2i \right)}={\varphi ^{-1}}\left( 1-\left[ 1-\varphi { {\left( m_{N/{2}\;}^{\left( i \right)} \right)}^{2}} \right] \right) \end{equation}\begin{equation} m_{N}^{\left( 2i \right)}=2m_{ {N}/{2}\;}^{\left( 2i \right)} \end{equation}\begin{equation} m_{1}^{\left( 1 \right)}={1}/{ { {\sigma }^{2}}}\; \end{equation}其中函数\begin{equation} \varphi \left( x \right)=\left\{ \begin{matrix} 1-\frac{1}{\sqrt{4\pi x}}\int_{-\infty }^{\infty }{\tanh \frac{u}{2}\cdot \exp \left( -\frac{ { {\left( u-x \right)}^{2}}}{4x} \right)du,x>0} \\ 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,x=0 \\ \end{matrix} \right. \end{equation}$\varphi \left( x \right)$在$\left[ 0,\infty \right)$上连续单调递减，$\varphi \left( 0 \right)\text{=}1$，$\varphi \left( \infty \right)\text{=0}$，其反函数用${ {\varphi }^{-1}}\left( x \right)$表示。一般情况下，函数$\varphi \left( x \right)$可以使用如下的近似形式计算\begin{equation} \varphi \left( x \right)=\left\{ \begin{matrix} \sqrt{\frac{\pi }{x}}\left( 1-\frac{10}{7x} \right)\exp \left( -\frac{x}{4} \right),x\ge 10 \\ \exp \left( -0.4527{ {x}^{-0.86}}+0.0218 \right),0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Polar Code（3）编码实例]]></title>
      <url>%2F2017%2F03%2F05%2Fpolar-code-3-encoding-example%2F</url>
      <content type="text"><![CDATA[前言在《Polar Code（2）编码原理》中详细阐述了Polar Code编码原理，为更好地理解编码过程，本文将给出一个编码实例。设码长为$N=8$，消息比特数$K=4$。列出所有使用到的公式：c_{1}^{N}=u_{1}^{N}{G_{N}}{G_{N}}={B_{N}}{F^{\otimes n}}{F^{\otimes n}}=F\otimes {F^{\otimes \left( n-1 \right)}}F=\left[ \begin{matrix} 1 & 0 \\ 1 & 1 \\ \end{matrix} \right]{B_{N}}={R_{N}}\left( {I_{2}}\otimes {B_{N/{2}\;}} \right){B_{2}}={I_{2}}计算各分裂子信道的错误概率计算出各个极化信道$W_{N}^{\left( i \right)}$的错误概率$P\left( {A_{i}} \right)$，选取$P\left( {A_{i}} \right)$最大的$K$个子信道放置信息比特，其他子信道放置固定比特。这一步的结果即得到$u_{1}^{N}$。假设对于一个BEC信道，采用计算巴氏参数获得$P\left( {A_{i}} \right)$最大的$K$个子信道序号为A=\left\{ 4,6,7,8 \right\}则固定比特序号集合为{A^{c}}=\left\{ 1,2,3,5 \right\}设信息比特集合为$\left( {i_{1}},{i_{2}},{i_{3}},{i_{4}} \right)=\left( 1,1,1,1 \right)$，固定比特集合为$\left( 0,0,0,0 \right)$，则最终得到u_{1}^{8}=\left[ 0,0,0,{i_{1}},0,{i_{2}},{i_{3}},{i_{4}} \right]=\left[ 0,0,0,1,0,1,1,1 \right]构造生成矩阵求排序矩阵BN递归式：{B_{8}}={R_{8}}\left( {I_{2}}\otimes {B_{4}} \right){B_{4}}={R_{4}}\left( {I_{2}}\otimes {B_{2}} \right)计算：{B_{2}}=\left[ \begin{matrix} 1 & 0 \\ 0 & 1 \\ \end{matrix} \right]{I_{2}}\otimes {B_{2}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{matrix} \right]${R_{4}}$由${I_{4}}$变换得来，先排${I_{4}}$的奇数列，再排${I_{4}}$的偶数列：{R_{4}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ \end{matrix} \right]\Leftarrow {I_{4}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{matrix} \right]{B_{4}}={R_{4}}\left( {I_{2}}\otimes {B_{2}} \right)=\left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ \end{matrix} \right]\cdot \left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ \end{matrix} \right]\text{=}\left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ \end{matrix} \right]{I_{2}}\otimes {B_{4}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right]${R_{8}}$由${I_{8}}$变换得来，先排${I_{8}}$的奇数列，再排${I_{8}}$的偶数列：{R_{8}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right]\Leftarrow {I_{8}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right]\begin{align} & {B_{8}}={R_{8}}\left( {I_{2}}\otimes {B_{4}} \right)=\left[ \nonumber \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right]\cdot \left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right] \\ & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{=} \left[ \nonumber \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right] \\ \end{align}求F的n次克罗内克积递归式：{F^{\otimes 3}}=F\otimes {F^{\otimes 2}}{F^{\otimes 2}}=F\otimes {F^{\otimes 1}}计算：{F^{\otimes 1}}\text{=}F=\left[ \begin{matrix} 1 & 0 \\ 1 & 1 \\ \end{matrix} \right]{F^{\otimes 2}}=F\otimes {F^{\otimes 1}}=\left[ \begin{matrix} 1 & 0 \\ 1 & 1 \\ \end{matrix} \right]\otimes {F^{\otimes 1}}=\left[ \begin{matrix} {F^{\otimes 1}} & 0 \\ {F^{\otimes 1}} & {F^{\otimes 1}} \\ \end{matrix} \right]=\left[ \begin{matrix} 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 \\ 1 & 0 & 1 & 0 \\ 1 & 1 & 1 & 1 \\ \end{matrix} \right]{F^{\otimes 3}}=F\otimes {F^{\otimes 2}}=\left[ \begin{matrix} 1 & 0 \\ 1 & 1 \\ \end{matrix} \right]\otimes {F^{\otimes 2}}=\left[ \begin{matrix} {F^{\otimes 2}} & 0 \\ {F^{\otimes 2}} & {F^{\otimes 2}} \\ \end{matrix} \right]\text{=}\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \end{matrix} \right]求生成矩阵GN\ \nonumber \begin{align} & {G_{8}}={B_{8}}{F^{\otimes 3}}=\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{matrix} \right]\cdot \left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \end{matrix} \right] \\ & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{=}\left[ \nonumber \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\ 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \end{matrix} \right] \\ \end{align}生成Polar Code\nonumber \begin{align} & c_{1}^{8}=u_{1}^{8}{G_{8}}=\left[ \begin{matrix} 0 & 0 & 0 & 1 & 0 & 1 & 1 & 1 \\ \end{matrix} \right]\cdot \left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\ 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \end{matrix} \right] \\ & \ \ \ \ =\left[ \nonumber \begin{matrix} 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 \\ \end{matrix} \right] \\ \end{align}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Polar Code（2）编码原理]]></title>
      <url>%2F2017%2F03%2F04%2Fpolar-code-2-encoding-principle%2F</url>
      <content type="text"><![CDATA[前言在《Polar Code（1）概述》中建立了Polar Code初步印象，本文将详细阐述Polar Code编码原理。Polar Code是通过引入信道极化概念而构建的。信道极化分为两个阶段，分别是信道联合和信道分裂。通过信道的联合与分裂，各个子信道的对称容量将呈现两级分化的趋势：随着码长（也就是联合信道数）$N$的增加，一部分子信道的容量趋于1，而其余子信道的容量趋于0。Polar Code正是利用这一信道极化的现象，在容量趋于1的$K$个子信道上传输消息比特，在其余子信道上传输冻结比特（即收发双方已知的固定比特，通常设置为全零）。由此构成的编码即为Polar Code，码率为${K}/{N}\;$。预备知识一个二进制输入离散无记忆信道（B-DMC）可表示为$W:X\to Y$，$X$是输入符号集合，$Y$是输出符号集合，转移概率为$W\left( y|x \right),x\in X,y\in Y$。由于信道是二进制输入，集合$X=\left\{ 0,1 \right\}$；$Y$和$W\left( y|x \right)$是任意值。对信道$W$的$N$次使用后的信道可表示为${W^{N}}$，则信道${W^{N}}:{X^{N}}\to {Y^{N}}$的转移概率为${W^{N}}\left( y_1^{N}|x_{1}^{N} \right)=\prod\nolimits_{i=1}^{N}{W\left( y|x \right)}$。对于一个B-DMC $W$，有两个重要的信道参数：对称容量（Symmetric Capacity）I\left( W \right)\triangleq \sum\limits_{y\in Y}{\sum\limits_{x\in X}{\frac{1}{2}}}W\left( y|x \right)\log \frac{W\left( y|x \right)}{\frac{1}{2}W\left( y|0 \right)+\frac{1}{2}W\left( y|1 \right)}巴氏参数（Bhattacharyya Parameter）Z\left( W \right)\triangleq \sum\limits_{y\in Y}{\sqrt{W\left( y|0 \right)W\left( y|1 \right)}}$I\left( W \right)$是对信道速率的度量，$Z\left( W \right)$对信道可靠性的度量。$I\left( W \right)$是信道$W$在等概率输入下的可靠传输时的最大速率；而$Z\left( W \right)$是信道$W$只传输0或1下的最大似然判决错误概率的上限。$I\left( W \right)$与$Z\left( W \right)$的取值范围均为$\left[ 0,1 \right]$。由于对数以2为底，因此码率和信道容量的单位为bit。$I\left( W \right)$与$Z\left( W \right)$满足这样的关系：且仅当$Z\left( W \right)\approx 0$时，$I\left( W \right)\approx 1$；当且仅当$Z\left( W \right)\approx 1$时，$I\left( W \right)\approx 0$。当$W$为对称信道时，$I\left( W \right)$等于香农容量。所谓信道对称，即满足：对于任意$y\in Y$，有$W\left( y|0 \right)=W\left( -y|1 \right)$。二进制对称信道（Binary Symmetric Channel，BSC）和二进制删除信道（Binary Erasure Channel，BEC）都是满足对称性的B-DMC。具体地说，对于$Y=\left\{ 0,1 \right\}$，满足$W\left( 0|0 \right)=W\left( 1|1 \right)$且$W\left( 1|0 \right)=W\left( 0|1 \right)$的B-DMC是为BSC。对于$y\in Y$，满足$W\left( y|0 \right)W\left( y|1 \right)=0$或$W\left( y|0 \right)=W\left( y|1 \right)$的B-DMC是为BEC。对于BEC，符号$y$称为删除符号（Erasure Symbol）。行向量$\left( {a_{1}},…,{a_{N}} \right)$在这里简写为$a_{1}^{N}$。对于给定的行向量$a_{1}^{N}$，其子向量表示为$a_{i}^{j},1\le i,j\le N$，且$i\le j$。对于给定的$a_{1}^{N}$和$A\subset \left\{ 1,…,N \right\}$，记${a_{A}}$表示子向量$\left( {a_{i}}:i\in A \right)$。记$a_{1,o}^{j}$表示奇数索引的子向量$\left( {a_{k}}:1\le k\le j;\begin{matrix}k &amp; odd \\\end{matrix} \right)$，记$a_{1,e}^{j}$表示偶数索引的子向量$\left( {a_{k}}:1\le k\le j;\begin{matrix}k &amp; even \\\end{matrix} \right)$。例如，对于向量$a_{1}^{5}=\left( 5,4,6,2,1 \right)$，有$a_{2}^{4}=\left( 4,6,2 \right)$，$a_{1,e}^{5}=\left( 4,2 \right)$，$a_{1,o}^{4}\left( 5,6 \right)$。全零向量则记为$0_{1}^{N}$。在此所讨论的向量、矩阵的运算均是在二元域上的运算，即GF（2）。记$\oplus $为模2加，记$\otimes $为克罗内克积（Kronecker Power）。记${A^{\otimes n}}$表示$A$的$n$次克罗内克积，有递归式${A^{\otimes n}}=A\otimes {A^{\otimes \left( n-1 \right)}},n\ge 1$，并且定义${A^{\otimes 0}}=\left[ 1 \right]$。记$\left| A \right|$表示集合$A$中元素的个数。记${1_{A}}$表示集合$A$的指示函数，若$x\in A$，则${1_{A\left( x \right)}}=1$；若$x\notin A$，则${1_{A\left( x \right)}}=0$。信道极化信道极化分为两个阶段：信道联合阶段（Channel Combining）和信道分裂（Channel Splitting）阶段。信道联合在这一阶段，联合B-DMC $W$的$N$个独立副本，通过递归方式产生一个向量信道${W_{N}}:{X^{N}}\to {Y^{N}}$，其中$N$为2的幂次$N={2^{n}},n\ge 0$。递归开始于第0级（$n=0$），只使用$W$的1个副本，并定义${W_{1}}\triangleq W$。第1级（$n=1$）递归联合了2个独立副本，如图1所示，得到向量信道${W_{2}}:{X^{2}}\to {Y^{2}}$，其转移概率为{W_{2}}\left( {y_{1}},{y_{2}}|{u_{1}},{u_{2}} \right)=W\left( {y_{1}}|{u_{1}}\oplus {u_{2}} \right)W\left( {y_{2}}|{u_{2}} \right)第2级（$n=0$）递归如图2所示，联合信道${W_{2}}$的2个独立副本得到信道${W_{4}}:{X^{4}}\to {Y^{4}}$，其转移概率为{W_{4}}\left( y_{1}^{4}|u_{1}^{4} \right)={W_{2}}\left( y_{1}^{2}|{u_{1}}\oplus {u_{2}},{u_{3}}\oplus {u_{4}} \right){W_{2}}\left( y_{3}^{4}|{u_{2}},{u_{4}} \right)在图2中，${R_{4}}$是完成从$\left( {s_{1}},{s_{2}},{s_{3}},{s_{4}} \right)$到$v_{1}^{4}=\left( {s_{1}},{s_{3}},{s_{2}},{s_{4}} \right)$的置换操作（排序）。从信道${W_{4}}$的输入${W^{4}}$的输入的映射$u_{1}^{4}\to x_{1}^{4}$可用公式表示为$x_{1}^{4}=u_{1}^{4}{G_{4}}$，${G_{4}}=\left[ \begin{matrix}1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 \\\end{matrix} \right]$。因此${W_{4}}$和${W^{4}}$的转移概率有关系式${W_{4}}\left( y_{1}^{4}|u_{1}^{4} \right)={W^{4}}\left( y_{1}^{4}|u_{1}^{4}{G_{4}} \right)$。图3所示为递归结构的一般形式。${W_{N/{2}\;}}$的2个独立副本联合产生信道${W_{N}}$。输入向量$u_{1}^{N}$进入信道${W_{N}}$，首先被转换为$s_{1}^{N}$：${s_{2i-1}}={u_{2i-1}}\oplus {u_{2i}}$，${s_{2i}}={u_{2i}}$，$1\le i\le {N}/{2}\;$。${R_{N}}$表示比特反转排序操作，输入为$s_{1}^{N}$，输出为$v_{1}^{N}=\left( {s_{1}},{s_{3}},…,{s_{N-1}},{s_{2}},{s_{4}},…,{s_{N}} \right)$。$v_{1}^{N}$则成为2个${W_{N/{2}\;}}$独立副本的输入。映射$u_{1}^{N}\to v_{1}^{N}$是二元域GF（2）上的线性变换。$u_{1}^{N}\to x_{1}^{N}$是由综合信道${W_{N}}$的输入到原始信道${W^{N}}$的输入的映射，其映射过程也是线性变换。因此有$x_{1}^{N}=u_{1}^{N}{G_{N}}$。称${G_{N}}$为$N$维生成矩阵。信道${W_{N}}$和${W^{N}}$的转移概率有如下关系：{W_{N}}\left( y_{1}^{N}|u_{1}^{N} \right)={W^{N}}\left( y_{1}^{N}|u_{1}^{N}{G_{N}} \right)其中$y_{1}^{N}\in {Y^{N}},u_{1}^{N}\in {X^{N}}$。信道分裂这是信道极化的第二阶段。将信道联合构成的综合信道${W_{N}}$分裂为$N$个二进制输入的坐标信道（Coordinate Channels）$W_{N}^{\left( i \right)}:X\to {Y^{N}}\times {X^{i-1}},1\le i\le N$，定义其转移概率为W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|{u_{i}} \right)\triangleq \sum\limits_{u_{i+1}^{N}\in {X^{N-i}}}{\frac{1}{2^{N-1}}{W_{N}}\left( y_{1}^{N}|u_{1}^{N} \right)}其中$\left( y_{1}^{N},u_{1}^{i-1} \right)$表示$W_{N}^{\left( i \right)}$的输出，而${u_{i}}$表示$W_{N}^{\left( i \right)}$的输入。奇序分裂子信道和偶序分裂子信道的转移概率由两个递归式得到。对任何$n\ge 0,N={2^{n}},1\le i\le {N}/{2}\;$，有W_{N}^{\left( 2i-1 \right)}\left( y_{1}^{N},u_{1}^{2i-2}|{u_{2i-1}} \right)=\sum\limits_{u_{2i}}{\frac{1}{2}W_{N/{2}\;}^{\left( i \right)}\left( y_{1}^{N/{2}\;},u_{1,o}^{2i-2}\oplus u_{1,e}^{2i-2}|{u_{2i-1}}\oplus {u_{2i}} \right)\cdot W_{N/{2}\;}^{\left( i \right)}\left( y_{N/{2}\;+1}^{N},u_{1,e}^{2i-2}|{u_{2i}} \right)}W_{N}^{\left( 2i \right)}\left( y_{1}^{N},u_{1}^{2i-1}|{u_{2i}} \right)=\frac{1}{2}W_{N/{2}\;}^{\left( i \right)}\left( y_{1}^{N/{2}\;},u_{1,o}^{2i-2}\oplus u_{1,e}^{2i-2}|{u_{2i-1}}\oplus {u_{2i}} \right)\cdot W_{N/{2}\;}^{\left( i \right)}\left( y_{N/{2}\;+1}^{N},u_{1,e}^{2i-2}|{u_{2i}} \right)信道极化定理定理1：对任意B-DMC $W$与任意$\delta \in \left( 0,1 \right)$，当$N$以2的幂次趋近于无穷大时，极化信道$W_{N}^{\left( i \right)}$中，满足$I\left( W_{N}^{\left( i \right)} \right)\in \left( 1-\delta ,1 \right]$的信道数占总信道数$N$的比例趋于$I\left( W \right)$；满足$I\left( W_{N}^{\left( i \right)} \right)\in \left[ 0,\delta \right)$的信道所占的比例趋于$1-I\left( W \right)$。定理2：对任意B-DMC $W$，$I\left( W \right)&gt;0$，且对任意$R&lt;I\left( W \right)$，存在一个序列集合${A_{N}}\subset \left\{ 1,…,N \right\},N\in \left\{ 1,2,…,{2^{n}},… \right\}$，对所有$i\in {A_{N}}$有$\left| {A_{N}} \right|\ge NR$且$Z\left( W_{N}^{\left( i \right)} \right)\le O\left( {N^{-5/{4}\;}} \right)$。极化编码利用极化现象构建的编码可以达到对称容量$I\left( W \right)$，是为极化编码（Polar Coding）。极化编码的基本思想是：只在$Z\left( W_{N}^{\left( i \right)} \right)$近于0的坐标信道$W_{N}^{\left( i \right)}$上发送数据比特。极化码具有一般的二元线性分组码的基本编码要素，因而可以通过显示地写出其生成矩阵来完成编码：x_{1}^{N}=u_{1}^{N}{G_{N}}其中$u_{1}^{N}$为待编码比特序列，$x_{1}^{N}$为编码后的比特序列，${G_{N}}$为生成矩阵，码长为$N={2^{n}}$。构造生成矩阵生成矩阵表示为{G_{N}}\text{=}{B_{N}}{F^{\otimes n}}其中${F^{\otimes n}}$表示对矩阵$F=\left[ \begin{matrix}1 &amp; 0 \\1 &amp; 1 \\\end{matrix} \right]$的$n$次克罗内克积，有递归式${F^{\otimes n}}\text{=}F\otimes {F^{\otimes \left( n-1 \right)}}$。${B_{N}}$是排序矩阵，用以完成比特反序重排操作。所有比特反序重排，就是将每个原序列的十进制序号$i\in \left\{ 1,2,…,N \right\}$按二进制表示为$\left( i-1 \right)\to \left( {b_{n}},{b_{n-1}},…,{b_{1}} \right)$，其中${b_{n}}$为最高有效位；再将该二进制序列反序，得到$\left( {b_{1}},{b_{2}},…,{b_{n}} \right)$；最后以${b_{1}}$为最高有效位重新按十进制表示成$\left( {b_{1}},{b_{2}},…,{b_{n}} \right)\to \left( j-1 \right)$，令输出序列的第$j$个元素取值为原序列的第$i$个元素。${B_{N}}$的递归式定义为{B_{N}}={R_{N}}\left( {I_{2}}\otimes {B_{N/{2}\;}} \right)其中${I_{2}}$为2维单位阵，${B_{2}}={I_{2}}$；矩阵${R_{N}}$为置换矩阵，对输入序列完成奇序元素和偶序元素的分离，即先排奇序元素，再排偶序元素，其作为效果如下\left( {u_{1}},{u_{2}},{u_{3}},{u_{4}},...,u{}_{N} \right)\times {R_{N}}=\left( {u_{1}},{u_{3}},{u_{5}},...,{u_{N-1}},{u_{2}},{u_{4}},{u_{6}},...,{u_{N}} \right)选择消息比特位置到目前，已经知道在给定序列$u_{1}^{N}$的情况下如何构造极化码，实际编码中的$u_{1}^{N}$并不是事先给定的。现在来考虑如何确定$u_{1}^{N}$中哪些比特位置用于传输消息比特，哪些比特位置用于传输冻结比特。一般地，对于码长为$N$，消息比特数为$K$的待编码序列，通过以下步骤获得消息比特的位置：step1：计算各个分裂信道$W_{N}^{\left( i \right)}$的错误概率；step2：将step1得到的$N$个错误概率值从小到大排序；step3：选择错误概率最小的$K$个分裂信道用于传输消息比特，其余分裂信道传输冻结比特。那么如果计算各个子信道的错误概率？Arikan针对BEC给出的方法是计算巴氏参数Z\left( W_{N}^{\left( i \right)} \right)=\sum\limits_{y_{1}^{N}\in {Y^{N}}}{\sum\limits_{u_{1}^{i-1}\in {X^{i-1}}}{\sqrt{W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|0 \right)W_{N}^{\left( i \right)}\left( y_{1}^{N},u_{1}^{i-1}|1 \right)}}}选择$Z\left( W_{N}^{\left( i \right)} \right)$近于0的子信道传输消息比特。总结本文首先介绍了Polar Code的预备知识，如对称容量、巴氏参数以及所涉及的数学符号的表示。其次介绍了信道极化的两个阶段：信道联合与信道分裂。最后阐述了Polar Code的编码过程：通过构造生成矩阵获得${G_{N}}$，通过计算各个分裂子信道的错误概率用以判断消息比特位置从而获得$u_{1}^{N}$；两者相乘$u_{1}^{N}{G_{N}}$即为Polar Code。极化码是一种线性分组码，通过构造生成矩阵而获得编码。只要给定码长$N$，编译码结构就唯一确定。极化码基于信道极化现象，做到了扬长而避短。在最可靠的子信道上传输消息比特是为扬长，在最不可靠的子信道上传输冻结比特是为避短。参考文献[1] Arikan E. Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels[J]. IEEE Transactions on Information Theory, 2008, 55(7):3051-3073.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Polar Code（1）概述]]></title>
      <url>%2F2017%2F03%2F01%2Fpolar-code-1-summary%2F</url>
      <content type="text"><![CDATA[2016年11月18日，在美国内华达州里诺进行的3GPP RAN1 #87次会议，最终确定Polar Code作为5G eMBB（增强移动宽带）场景下控制信道编码方案。2008年，Erdal Arikan在国际信息论ISIT会议上首次提出了信道极化（Channel Polarization）的概念；2009年在“IEEE Transaction on Information Theory”期刊上发表了一篇长达23页的论文更加详细地阐述了信道极化，并基于信道极化给出了一种新的编码方式，名称为极化码（Polar Code）。极化码具有确定性的构造方法，并且是已知的唯一一种能够被严格证明“达到”信道容量的信道编码方法。从代数编码和概率编码的角度来说，极化码具备了两者各自的特点。首先，只要给定编码长度，极化码的编译码结构就唯一确定了，而且可以通过生成矩阵的形式完成编码过程，这一点和代数编码的常见思维是一致的。其次，极化码在设计时并没有考虑最小距离特性，而是利用了信道联合（Channel Combination）与信道分裂（Channel Splitting）的过程来选择具体的编码方案，而且在译码时也是采用概率算法，这一点比较符合概率编码的思想。对于长度为$N={2^{n}}$（$n$为任意正整数）的极化码，它利用信道$W$的N个独立副本，进行信道联合和信道分裂，得到新的N个分裂之后的信道$\left\{ W_{N}^{\left( 1 \right)},W_{N}^{\left( 2 \right)},…,W_{N}^{\left( N \right)} \right\}$。随着码长N的增加，分裂之后的信道将向两个极端发展：其中一部分分裂信道会趋近于完美信道，即信道容量趋近于1的无噪声信道；而另一部分分裂信道会趋近于完全噪声信道，即信道容量趋近于0的信道。假设原信道$W$的二进制输入对称容量记作$I\left(W\right)$，那么当码长N趋近于无穷大时，信道容量趋近于1的分裂信道比例约为$K=N\times I\left( W \right)$，而信道容量趋近于0的比例约为$N\times \left( 1-I\left( W \right) \right)$。对于信道容量为1的可靠信道，可以直接放置消息比特而不采用任何编码，即相当于编码速率为$R=1$；而对于信道容量为0的不可靠信道，可以放置发送端和接收端都事先已知的冻结比特，即相当于编码速率为$R=0$。那么当码长$N\to \infty $时，极化码的可达编码速率$R=N\times I\left(W\right)/N=I\left(W\right)$，即在理论上，极化码可以被证明是可达信道容量的。在极化码编码时，首先要区分出N个分裂信道的可靠程度，即哪些属于可靠信道，哪些属于不可靠信道。对各个极化信道的可靠性进行度量常用的有三种方法：巴氏参数（Bhattacharyya Parameter）法、密度进化（Density Evolution，DE）法和高斯近似（Gaussian Approximation）法：最初，极化码采用巴氏参数$Z\left( W \right)$来作为每个分裂信道的可靠性度量，$Z\left( W \right)$越大表示信道的可靠程度越低。当信道$W$是二元删除信道（Binary Erasure Channel，BEC）时，每个$Z\left( W_{N}^{\left( i \right)} \right)$都可以采用递归的方式计算出来，复杂度为$O\left( N\log N \right)$。然而，对于其他信道，如二进制输入对称信道（Binary-input Symmeric Channel，BSC）或者二进制输入加性高斯白噪声信道（Binary-input Additive White Gaussian Channel，BAWGNC）并不存在准确的能够计算$Z\left( W_{N}^{\left( i \right)} \right)$的方法。因此，Mori等人提出了一种采用密度进化方法跟踪每个子信道概率密度函数（Probability Density Function，PDF），从而估计每个子信道错误概率的方法。这种方法适用于所有类型的二进制输入离散无记忆信道（Binary-input Discrete Memoryless Channel，B-DMC）信道。在大多数研究场景下，信道编码的传输信道模型均为BAWGNC信道。在BAWGNC信道下，可以将密度进化中的对数似然比（Likelihood Rate，LLR）的概率密度函数用一族方差为均值2倍的高斯分布来近似，从而简化成了对一维均值的计算，大大降低计算量，这种对DE的简化计算即为高斯近似。参考文献：[1] Arikan E. Channel polarization: A method for constructing capacity-achieving codes[C]// IEEE International Symposium on Information Theory. IEEE, 2008:1173-1177.[2] Arikan E. Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels[J]. IEEE Transactions on Information Theory, 2008, 55(7):3051-3073.[3] 陈凯. 极化编码理论与实用方案研究[D]. 北京邮电大学, 2014.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开宗明义]]></title>
      <url>%2F2017%2F03%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[首篇博文，开宗明义。这是一个无线通信技术博客，主要用于记录自己在工作中对无线通信知识的梳理、总结或学习笔记。博客内容涉及但不限于5G技术预研、NB-IOT物理层算法以及LTE物理层算法。工作中每个研究阶段有每个阶段的任务，研究完一个方向，继而转入下一个新方向。若不对这些知识碎片及时整理，时间一长难免淡忘。若能坚持写技术博客，不断完成对新知识的梳理和对旧知识的回顾是大有裨益的。故开博以记之。Weibo: @Marshall_MSEmail: marshallcomm@163.com]]></content>
    </entry>

    
  
  
</search>
